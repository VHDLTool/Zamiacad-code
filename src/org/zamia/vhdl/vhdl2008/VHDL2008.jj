
options {
  STATIC = false;
  //LOOKAHEAD = 5;
  
  // DEBUG_PARSER = true;
  // CHOICE_AMBIGUITY_CHECK=3;
  IGNORE_CASE=false;
  USER_CHAR_STREAM = true;
  UNICODE_INPUT = true;
  CACHE_TOKENS = true;
}

PARSER_BEGIN(VHDL2008Parser)

/* 
 * Copyright 2007-2009 by the authors indicated in the @author tags. 
 * All rights reserved. 
 * 
 * See the LICENSE file for details.
 * 
 * 
 */

package org.zamia.vhdl.vhdl2008;

import java.io.IOException;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;

import org.zamia.DMManager;
import org.zamia.ERManager;
import org.zamia.IHDLParser;
import org.zamia.SourceFile;
import org.zamia.SourceLocation;
import org.zamia.ZamiaException;
import org.zamia.ZamiaLogger;
import org.zamia.ZamiaProject;
import org.zamia.instgraph.IGObject.IGObjectCat;
import org.zamia.instgraph.IGObject.OIDir;
import org.zamia.util.HashSetArray;
import org.zamia.vhdl.ast.*;
import org.zamia.vhdl.ast.EntityAspect.EntityAspectKind;
import org.zamia.vhdl.ast.OperationCompare.CompareOp;
import org.zamia.vhdl.ast.OperationLiteral.LiteralCat;
import org.zamia.vhdl.ast.OperationLogic.LogicOp;
import org.zamia.vhdl.ast.OperationMath.MathOp;
import org.zamia.vhdl.ast.OperationShift.ShiftOp;
import org.zamia.zdb.ZDB;


/**
 * @author Guenter Bartsch
 */

@SuppressWarnings("all")
public class VHDL2008Parser implements IHDLParser {

	private enum InterfaceContext { FUNCTION, PROCEDURE, PORT, GENERIC };
	
	public final static boolean dump = false;
	private SourceFile sf;
	private String lib;
	public final static ZamiaLogger logger = ZamiaLogger.getInstance();
	private ZamiaProject zprj;
    private DMManager dum;
    private ERManager erm;
    private HashSetArray<DMUID> dus;
	private BackupCharStream stream;
	private int priority;
	private boolean fUseFSCache;
	private boolean bottomUp;
	private ZDB zdb;
	
	public VHDL2008Parser() {
		this (new BackupCharStream(new StringReader("")));
	}
	
    private long getLocation(Token token_) {
    	
    	return token_ == null ? 0 : (long) token_.beginLine | ((long) token_.beginColumn) << 32;
    }
    
    private long getLocation () {
    	Token t = getToken(0);
    	if (t.next != null)
    		t = t.next;
    	return getLocation (t);
    }
    
	public HashSetArray<DMUID> parse(Reader aReader, String aLibId, SourceFile aSF, int aPriority, boolean aUseFSCache, boolean aBottomUp, ZamiaProject aZPrj) throws IOException {
			logger.debug("VHDL2008Parser: parsing %s, target lib : %s", aSF, aLibId);
    
    		dus = new HashSetArray<DMUID>();

			zprj = aZPrj;
			dum = zprj.getDUM();    
			erm = zprj.getERM();    
			zdb = zprj.getZDB();
            lib = aLibId;
	    	stream = new BackupCharStream(aReader);
	    	priority = aPriority;
	    	fUseFSCache = aUseFSCache;
	    	bottomUp = aBottomUp;
	    	sf = aSF;
            
            try {
		            ReInit (stream);
                    design_file ();
            } catch (ZamiaException e2) {
              erm.addError (new ZamiaException (e2.toString(), e2.getLocation()));
            } catch (ParseException e3) {
              erm.addError (new ZamiaException (e3.getMessage(), new SourceLocation(sf, getLocation(e3.currentToken.next))));
            } catch (TokenMgrError e4) {
              erm.addError (new ZamiaException (e4.getMessage(), new SourceLocation(sf,e4.line,e4.col)));
            }
            sf.setNumLines(stream.getEndLine());
            sf.setNumChars(stream.getNumChars());
            return dus;
    }
    
    // JavaCC hack for doing lexical state transitions syntactically

	private void SetState(int state) {
       if (state != token_source.curLexState) {
        	
      	  	int backupCol = jj_nt.beginColumn;
      	  	int backupLine = jj_nt.beginLine;
        	  
			int curCol = stream.getEndColumn();
			int curLine = stream.getEndLine();
       	  
			while (curCol > backupCol || curLine > backupLine) {
        	  
        		stream.backup(1);
            	curCol = stream.getEndColumn();
            	curLine = stream.getEndLine();
        	}
        	
        	if (curCol == backupCol && curLine == backupLine) {
        		stream.backup(1);
        	}

            token_source.SwitchTo(state);
            
            jj_nt = token_source.getNextToken();
            jj_scanpos.next = jj_nt;
       }
	}
    
}

PARSER_END(VHDL2008Parser)

TOKEN_MGR_DECLS : {

    // Required by SetState
    void backup(int n) { input_stream.backup(n); } 

} 

<REPORT_TICKS_MODE,DEFAULT,PSL_MODE,PSL_MODE_TICKS>SKIP :
{
    " "
  | "\n"
  | "\r"
  | "\t"
  | "\b"
  | "\0"
  | "\f"
  | "\u00a0"
  | "\ufffd"
}

<REPORT_TICKS_MODE,DEFAULT,PSL_MODE,PSL_MODE_TICKS>SPECIAL_TOKEN : {
    < SINGLE_LINE_COMMENT: "--"(~["\n","\r"])* ("\n"|"\r"|"\r\n")? > 
} 

//<REPORT_TICKS_MODE,DEFAULT>SPECIAL_TOKEN :
//{
//  <COMMENT: "--" (~["\n"])* ("\n"|"\r\n"|<EOF>)> : DEFAULT
//}

<REPORT_TICKS_MODE,DEFAULT>TOKEN [IGNORE_CASE] :
{
    <IF:            "if"> : DEFAULT
  | <IS:            "is"> : DEFAULT
  | <IN:            "in"> : DEFAULT
  | <TO:            "to"> : DEFAULT
  | <OF:            "of"> : DEFAULT
  | <ON:            "on"> : DEFAULT
  | <OR:            "or"> : DEFAULT
  | <FOR:           "for"> : DEFAULT
  | <USE:           "use"> : DEFAULT
  | <SLA:           "sla"> : DEFAULT
  | <SLL:           "sll"> : DEFAULT
  | <SRA:           "sra"> : DEFAULT
  | <SRL:           "srl"> : DEFAULT
  | <ROL:           "rol"> : DEFAULT
  | <ROR:           "ror"> : DEFAULT
  | <MAP:           "map"> : DEFAULT
  | <BUS:           "bus"> : DEFAULT
  | <ALL:           "all"> : DEFAULT
  | <AND:           "and"> : DEFAULT
  | <ABS:           "abs"> : DEFAULT
  | <MOD:           "mod"> : DEFAULT 
  | <NEW:           "new"> : DEFAULT
  | <XOR:           "xor"> : DEFAULT
  | <NOR:           "nor"> : DEFAULT
  | <NOT:           "not"> : DEFAULT
  | <REM:           "rem"> : DEFAULT
  | <OUT:           "out"> : DEFAULT
  | <NULL:          "null"> : DEFAULT
  | <XNOR:          "xnor"> : DEFAULT
  | <THEN:          "then"> : DEFAULT
  | <NAND:          "nand"> : DEFAULT
  | <PURE:          "pure"> : DEFAULT
  | <OPEN:          "open"> : DEFAULT
  | <END:           "end"> : DEFAULT
  | <WAIT:          "wait"> : DEFAULT
  | <WHEN:          "when"> : DEFAULT
  | <CASE:          "case"> : DEFAULT
  | <WITH:          "with"> : DEFAULT
  | <FILE:          "file"> : DEFAULT
  | <EXIT:          "exit"> : DEFAULT
  | <PORT:          "port"> : DEFAULT
  | <BODY:          "body"> : DEFAULT
  | <TYPE:          "type"> : DEFAULT
  | <LOOP:          "loop"> : DEFAULT
  | <ELSE:          "else"> : DEFAULT
  | <BEGIN:         "begin"> : DEFAULT
  | <WHILE:         "while"> : DEFAULT
  | <UNITS:         "units"> : DEFAULT
  | <AFTER:         "after"> : DEFAULT
  | <INOUT:         "inout"> : DEFAULT
  | <LABEL:         "label"> : DEFAULT
  | <ARRAY:         "array"> : DEFAULT
  | <RANGE:         "range"> : DEFAULT
  | <ALIAS:         "alias"> : DEFAULT
  | <GROUP:         "group"> : DEFAULT
  | <BLOCK:         "block"> : DEFAULT
  | <ELSIF:         "elsif"> : DEFAULT
  | <OTHERS:        "others"> : DEFAULT
  | <REJECT:        "reject"> : DEFAULT
  | <BUFFER:        "buffer"> : DEFAULT
  | <RETURN:        "return"> : DEFAULT
  | <SELECT:        "select"> : DEFAULT
  | <ACCESS:        "access"> : DEFAULT
  | <ACROSS:        "across"> : DEFAULT
  | <SIGNAL:        "signal"> : DEFAULT
  | <SHARED:        "shared"> : DEFAULT
  | <DOWNTO:        "downto"> : DEFAULT
  | <IMPURE:        "impure"> : DEFAULT
  | <RECORD:        "record"> : DEFAULT
  | <ENTITY:        "entity"> : DEFAULT
  | <LIBRARY:       "library"> : DEFAULT
  | <LINKAGE:       "linkage"> : DEFAULT
  | <LITERAL:       "literal"> : DEFAULT
  | <PACKAGE:       "package"> : DEFAULT
  | <GENERIC:       "generic"> : DEFAULT
  | <PROCESS:       "process"> : DEFAULT
  | <SUBTYPE:       "subtype"> : DEFAULT
  | <GUARDED:       "guarded"> : DEFAULT
  | <CONSTANT:      "constant"> : DEFAULT
  | <REGISTER:      "register"> : DEFAULT
  | <SEVERITY:      "severity"> : DEFAULT
  | <FUNCTION:      "function"> : DEFAULT
  | <GENERATE:      "generate"> : DEFAULT
  | <INERTIAL:      "inertial"> : DEFAULT
  | <POSTPONED:     "postponed"> : DEFAULT
  | <ATTRIBUTE:     "attribute"> : DEFAULT
  | <COMPONENT:     "component"> : DEFAULT
  | <DISCONNECT:    "disconnect"> : DEFAULT
  | <ARCHITECTURE:  "architecture"> : DEFAULT
  | <CONFIGURATION: "configuration"> : DEFAULT
  | <PROCEDURAL:    "procedural"> : DEFAULT
  | <PROCEDURE:     "procedure"> : DEFAULT
  | <PROTECTED:     "protected"> : DEFAULT
  | <QUANTITY:      "quantity"> : DEFAULT
  | <TRANSPORT:     "transport"> : DEFAULT
  | <UNAFFECTED:    "unaffected"> : DEFAULT
  | <VARIABLE:      "variable"> : DEFAULT
  
  // shared with PSL:
  
  | <ASSERT:        "assert">
  | <NEXT:          "next"> 
  | <REPORT:        "report"> 
  | <UNTIL:         "until">
  
  // PSL entry:

  | <PSL_COVER:     "cover"> : PSL_MODE
} 

<DEFAULT>TOKEN:
{
  <character_literal:                "'" (" ")*(<graphic_character>|"\"") (" ")* "'">
}

<REPORT_TICKS_MODE,DEFAULT>TOKEN [IGNORE_CASE] :
{

    <#digit:                           ["0"-"9"]>
  | <#hex_digit:                       ["0"-"9","A"-"F"]>
  
  | <#integer:                         <digit> (("_")? <digit>)*>
  | <#base:                            <integer> >
  | <#based_integer:                   (("_")? <hex_digit>)*>
  | <#exponent:                        ("E" ("+")? <integer>) | ("E" "-" <integer>)>
  | <based_literal:                    <base> "#" <based_integer> ("." <based_integer>)? "#" (<exponent>)?> : DEFAULT
  | <decimal_literal:                  <integer> ( "." <integer>)? ( <exponent> )?> : DEFAULT

  | <#base_specifier:                  ["B","O","X"]>
  | <#bit_value:                       <hex_digit> ( ("_")* <hex_digit>)*>
  | <bit_string_literal:               <base_specifier> "\"" <bit_value> "\""> : DEFAULT

  | <#letter:                          ["a"-"z","A"-"Z"]>
  | <#letter_or_digit:                 ["a"-"z","A"-"Z","0"-"9"]>
  | <basic_identifier:                 <letter> ( ("_")? <letter_or_digit> )*> : REPORT_TICKS_MODE

  | <#special_character:               ["#","&","'","(",")","*","+",",","-",".","/",":",";","<","=",">","[","]","_","|","!","$","%","@","?","^","`","{","}","~"," ","\u00a0"-"\uffff"]>
  | <#format_effector:                 ["\n","\t","\b","\f","\r"]>
  | <#egraphic_character:              (<letter_or_digit>|<special_character>|<format_effector>)>
  | <#graphic_character:               (<egraphic_character>|"\\")>
 
  | <extended_identifier:              "\\" (<egraphic_character> | "\\\\") ( (<egraphic_character> | "\\\\") )* "\\"> : REPORT_TICKS_MODE
  
  | <string_literal:                   "\"" (<graphic_character>|"\"\"")* "\""> : DEFAULT

  | <EXP: "**"> : DEFAULT
  | <MUL: "*"> : DEFAULT
  | <DIV: "/"> : DEFAULT
  | <ADD: "+"> : DEFAULT
  | <SUB: "-"> : DEFAULT
  | <CONCAT: "&"> : DEFAULT
  | <EQ:  "="> : DEFAULT
  | <NEQ: "/="> : DEFAULT
  | <GE:  ">="> : DEFAULT
  | <LE:  "<="> : DEFAULT
  | <GT:  ">"> : DEFAULT
  | <LO:  "<"> : DEFAULT
  | <SEMICOLON: ";"> : DEFAULT
  | <COMMA: ","> : DEFAULT
  | <COLON: ":"> : DEFAULT
  | <BOX: "<>"> : DEFAULT
  | <TICK: "'"> : DEFAULT
  | <LPAREN: "("> : DEFAULT
  | <RPAREN: ")"> : DEFAULT
  | <LBRACKET: "["> : DEFAULT
  | <RBRACKET: "]"> : DEFAULT
  | <ASSIGN: ":="> : DEFAULT
  | <PERIOD: "."> : DEFAULT
  | <FOLLOWS: "=>"> : DEFAULT
  | <PIPE: "|"> : DEFAULT
  | <LBRACE: "{"> : DEFAULT
  | <RBRACE: "}"> : DEFAULT
} 

//
//
// PSL-only tokens start here
//
//

<PSL_MODE>TOKEN:
{
  <psl_character_literal:                "'" (" ")*(<graphic_character>|"\"") (" ")* "'">
}


<PSL_MODE, PSL_MODE_TICKS>TOKEN [IGNORE_CASE] :
{
  <PSL_NOT: "not"> : PSL_MODE
  | <PSL_AND: "and"> : PSL_MODE
  | <PSL_OR: "or"> : PSL_MODE
  | <PSL_TO: "to"> : PSL_MODE
  | <PSL_NAND: "nand"> : PSL_MODE
  | <PSL_NOR: "nor"> : PSL_MODE
  | <PSL_XOR: "xor"> : PSL_MODE
  | <PSL_XNOR: "xnor"> : PSL_MODE
  | <PSL_SLL: "sll"> : PSL_MODE
  | <PSL_SRL: "srl"> : PSL_MODE
  | <PSL_SLA: "sla"> : PSL_MODE
  | <PSL_SRA: "sra"> : PSL_MODE
  | <PSL_ROL: "rol"> : PSL_MODE
  | <PSL_ROR: "ror"> : PSL_MODE
  | <PSL_NEW: "new"> : PSL_MODE
  | <PSL_MOD: "mod"> : PSL_MODE
  | <PSL_REM: "rem"> : PSL_MODE
  | <PSL_ABS: "abs"> : PSL_MODE
  | <PSL_ALL: "all"> : PSL_MODE
  | <PSL_NULL: "null"> : PSL_MODE
  | <PSL_OTHERS: "others"> : PSL_MODE
  | <PSL_DOWNTO: "downto"> : PSL_MODE
  | <PSL_RANGE: "range"> : PSL_MODE
  | <PSL_RETURN: "return"> : PSL_MODE
  | <PSL_OPEN: "open"> : PSL_MODE
  | <PSL_IN: "in"> : PSL_MODE
}

<PSL_MODE, PSL_MODE_TICKS>TOKEN :
{
  <PSL_A: "A"> : PSL_MODE 
  |<PSL_ABORT: "abort"> : PSL_MODE
  |<PSL_AF: "AF"> : PSL_MODE
  |<PSL_AG: "AG"> : PSL_MODE
  |<PSL_ALWAYS: "always"> : PSL_MODE
  |<PSL_ANDA: "anda"> : PSL_MODE
  |<PSL_ASSERT: "assert"> : PSL_MODE
  |<PSL_ASYNC_ABORT: "async_abort"> : PSL_MODE
  |<PSL_BEFORE: "before"> : PSL_MODE
  |<PSL_BEFORE_: "before_"> : PSL_MODE
  |<PSL_BEFOREEXCL: "before!"> : PSL_MODE
  |<PSL_BEFOREEXCL_: "before!_"> : PSL_MODE
  |<PSL_BOOLEAN: "boolean"> : PSL_MODE
  |<PSL_CLOCK: "clock"> : PSL_MODE
  |<PSL_CONST: "const"> : PSL_MODE
  |<PSL_COUNTONES: "countones"> : PSL_MODE
  |<PSL_E: "E"> : PSL_MODE
  |<PSL_EF: "EF"> : PSL_MODE
  |<PSL_EG: "EG"> : PSL_MODE
  |<PSL_ENDED: "ended"> : PSL_MODE
  |<PSL_EVENTUALLYEXCL: "eventually!"> : PSL_MODE
  |<PSL_EX: "EX"> : PSL_MODE
  |<PSL_F: "F"> : PSL_MODE
  |<PSL_FELL: "fell"> : PSL_MODE
  |<PSL_FORALL: "forall"> : PSL_MODE
  | <PSL_G: "G"> : PSL_MODE
  | <PSL_HDLTYPE: "hdltype"> : PSL_MODE
  | <PSL_INF: "inf"> : PSL_MODE
  | <PSL_INHERIT: "inherit"> : PSL_MODE
  | <PSL_ISB: "isb"> : PSL_MODE
  | <PSL_ISUNKNOWN: "isunknown"> : PSL_MODE
  | <PSL_NEVER: "never"> : PSL_MODE
  | <PSL_NEXTEXCL: "next!"> : PSL_MODE
  | <PSL_NEXT_A: "next_a"> : PSL_MODE
  | <PSL_NEXT_AEXCL: "next_a!"> : PSL_MODE
  | <PSL_NEXT_E: "next_e"> : PSL_MODE
  | <PSL_NEXT_EEXCL: "next_e!"> : PSL_MODE
  | <PSL_NEXT_EVENT: "next_event"> : PSL_MODE
  | <PSL_NEXT_EVENTEXCL: "next_event!"> : PSL_MODE
  | <PSL_NEXT_EVENT_A: "next_event_a"> : PSL_MODE
  | <PSL_NEXT_EVENT_AEXCL: "next_event_a!"> : PSL_MODE
  | <PSL_NEXT_EVENT_E: "next_event_e"> : PSL_MODE
  | <PSL_NEXT_EVENT_EEXCL: "next_event_e!"> : PSL_MODE
  | <PSL_NONDET: "nondet"> : PSL_MODE
  | <PSL_NONDET_VECTOR: "nondet_vector"> : PSL_MODE
  | <PSL_NOTC: "notc"> : PSL_MODE
  | <PSL_ONEHOT: "onehot"> : PSL_MODE
  | <PSL_ONEHOT0: "onehot0"> : PSL_MODE
  | <PSL_ORD: "ord"> : PSL_MODE
  | <PSL_PREV: "prev"> : PSL_MODE
  | <PSL_ROSE: "rose"> : PSL_MODE
  | <PSL_STABLE: "stable"> : PSL_MODE
  | <PSL_SYNC_ABORT: "sync_abort"> : PSL_MODE
  | <PSL_TOE: "toe"> : PSL_MODE
  | <PSL_U: "U"> : PSL_MODE
  | <PSL_UNION: "union"> : PSL_MODE
  | <PSL_UNTIL_: "until_"> : PSL_MODE
  | <PSL_UNTILEXCL: "until!"> : PSL_MODE
  | <PSL_UNTILEXCL_: "until!_"> : PSL_MODE
  | <PSL_W: "W"> : PSL_MODE
  | <PSL_WITHIN: "within"> : PSL_MODE
  | <PSL_X: "X"> : PSL_MODE
  | <PSL_XEXCL: "X!"> : PSL_MODE
  | <PSL_ASSUME:             "assume"> : PSL_MODE
  | <PSL_ASSUME_GUARANTEE:   "assume_guarantee"> : PSL_MODE
  | <PSL_DEFAULT:            "default"> : PSL_MODE
  | <PSL_FAIRNESS:           "fairness"> : PSL_MODE
  | <PSL_NEXT:               "next"> : PSL_MODE 
  | <PSL_PROPERTY:           "property"> : PSL_MODE
  | <PSL_REPORT:             "report"> : PSL_MODE
  | <PSL_RESTRICT:           "restrict"> : PSL_MODE
  | <PSL_RESTRICT_GUARANTEE: "restrict_guarantee"> : PSL_MODE
  | <PSL_SEQUENCE:           "sequence"> : PSL_MODE
  | <PSL_STRONG:             "strong"> : PSL_MODE
  | <PSL_VMODE:              "vmode"> : PSL_MODE
  | <PSL_VPROP:              "vprop"> : PSL_MODE
  | <PSL_VUNIT:              "VUNIT"> : PSL_MODE
  | <PSL_UNTIL:              "until"> : PSL_MODE
}

<PSL_MODE,PSL_MODE_TICKS>TOKEN [IGNORE_CASE] :
{
    <#psl_digit:                           ["0"-"9"]>
  | <#psl_hex_digit:                       ["0"-"9","A"-"F"]>
  
  | <#psl_integer:                         <psl_digit> (("_")? <psl_digit>)*>
  | <#psl_base:                            <psl_integer> >
  | <#psl_based_integer:                   (("_")? <psl_hex_digit>)*>
  | <#psl_exponent:                        ("E" ("+")? <psl_integer>) | ("E" "-" <psl_integer>)>
  | <psl_based_literal:                    <psl_base> "#" <psl_based_integer> ("." <psl_based_integer>)? "#" (<psl_exponent>)?> : PSL_MODE
  | <psl_decimal_literal:                  <psl_integer> ( "." <psl_integer>)? ( <psl_exponent> )?> : PSL_MODE

  | <#psl_base_specifier:                  ["B","O","X"]>
  | <#psl_bit_value:                       <psl_hex_digit> ( ("_")* <psl_hex_digit>)*>
  | <psl_bit_string_literal:               <psl_base_specifier> "\"" <psl_bit_value> "\""> : PSL_MODE

  | <#psl_letter:                          ["a"-"z","A"-"Z"]>
  | <#psl_letter_or_digit:                 ["a"-"z","A"-"Z","0"-"9"]>
  | <psl_basic_identifier:                 <psl_letter> ( ("_")? <psl_letter_or_digit> )*> : PSL_MODE_TICKS

  | <#psl_special_character:               ["#","&","'","(",")","*","+",",","-",".","/",":",";","<","=",">","[","]","_","|","!","$","%","@","?","^","`","{","}","~"," ","\u00a0"-"\uffff"]>
  | <#psl_format_effector:                 ["\n","\t","\b","\f","\r"]>
  | <#psl_egraphic_character:              (<psl_letter_or_digit>|<psl_special_character>|<psl_format_effector>)>
  | <#psl_graphic_character:               (<psl_egraphic_character>|"\\")>
 
  | <psl_extended_identifier:              "\\" (<psl_egraphic_character> | "\\\\") ( (<psl_egraphic_character> | "\\\\") )* "\\"> : PSL_MODE_TICKS
  
  | <psl_string_literal:                   "\"" (<psl_graphic_character>|"\"\"")* "\""> : PSL_MODE

  | <PSL_EXP: "**"> : PSL_MODE
  | <PSL_MUL: "*"> : PSL_MODE
  | <PSL_DIV: "/"> : PSL_MODE
  | <PSL_ADD: "+"> : PSL_MODE
  | <PSL_SUB: "-"> : PSL_MODE
  | <PSL_CONCAT: "&"> : PSL_MODE
  | <PSL_EQ:  "="> : PSL_MODE
  | <PSL_NEQ: "/="> : PSL_MODE
  | <PSL_GE:  ">="> : PSL_MODE
  | <PSL_LE:  "<="> : PSL_MODE
  | <PSL_GT:  ">"> : PSL_MODE
  | <PSL_LO:  "<"> : PSL_MODE
  | <PSL_FOLLOWS: "=>"> : PSL_MODE

  | <PSL_LBRACKET:       "[">   : PSL_MODE
  | <PSL_RBRACKET:       "]">   : PSL_MODE
  | <PSL_LPAREN:         "(">   : PSL_MODE
  | <PSL_RPAREN:         ")">   : PSL_MODE
  | <PSL_LBRACE:         "{">   : PSL_MODE
  | <PSL_RBRACE:         "}">   : PSL_MODE
  | <PSL_COMMA:          ",">   : PSL_MODE
  | <PSL_SEMICOLON:      ";">   : PSL_MODE
  | <PSL_COLON:          ":">   : PSL_MODE
  | <PSL_DOTS:           "..">  : PSL_MODE
  | <PSL_ASSIGN:         ":=">  : PSL_MODE
  | <PSL_SUFFOVERLAP:    "|->"> : PSL_MODE
  | <PSL_SUFFNONOVERLAP: "|=>"> : PSL_MODE
  | <PSL_IMPLIFF:        "<->"> : PSL_MODE
  | <PSL_IMPLIF:         "->">  : PSL_MODE
  | <PSL_REPSTAR:        "[*">  : PSL_MODE
  | <PSL_REPPLUS:        "[+]"> : PSL_MODE
  | <PSL_REPGOTO:        "[->"> : PSL_MODE
  | <PSL_REPNON:         "[=">  : PSL_MODE
  | <PSL_LAND:           "&&">  : PSL_MODE 
  | <PSL_LOR:            "||">  : PSL_MODE
  | <PSL_PIPE:           "|">   : PSL_MODE
  | <PSL_EXCL:           "!">   : PSL_MODE
  | <PSL_DOLLAR:         "$">   : PSL_MODE
  | <PSL_AT:             "@">   : PSL_MODE
  | <PSL_PERIOD:         ".">   : PSL_MODE
  | <PSL_TICK:           "'">   : PSL_MODE
} 


void design_file() throws ZamiaException :
{
	boolean standardMode;
	DesignUnit du;
}
{
	{
		if (dump) logger.debug ("Compiling %s", sf.toString());
		
		// are we compiling the "standard" package here?
		// if so, according to IEEE Std 1076 we
		// start with an empty context,
		// otherwise all contexts are implicitly
		// loaded with
		// library STD, WORK; use STD.STANDARD.all;
		standardMode = false;
		if (sf != null) {
			if (sf.getFileName().endsWith("standard.vhdl"))
				standardMode = true;
		}
	}
	
    ( du = design_unit(standardMode) 
      { 
      	if (du!=null) {

          du.visit(new SourceLocationGenerator(sf));
      	  
      	  dum.addDesignUnit(du, sf, lib, priority, fUseFSCache);
      	  dus.add(du.getDMUID()); 
      	}
      } 
    )* <EOF>
}

DesignUnit design_unit(boolean standardMode_) throws ZamiaException:
{
	Context context;
	DesignUnit du;
}
{
	{ if (dump) System.out.println (">>> design_unit, stdMode="+standardMode_); }
	context = context_clause() 
	du = library_unit(context)
	{ 
		
		if (!(du instanceof Entity) && !standardMode_) {
			// library STD, WORK;
			context.addLibrary("STD", 0);
			context.addLibrary("WORK", 0);
			// use STD.STANDARD.all;
			Name name = new Name("STD", null, 0);
			name.addId("STANDARD", 0);
			name.addId("ALL", 0);
			context.addUse(name);
		}
		
		
		if (dump) System.out.println ("<<< design_unit"); 
		return du;
	}
}

Context context_clause() throws ZamiaException:
{
	Context context;
}
{
	{
		context = new Context(null, getLocation());
	}
	
  	( context_item(context) )*
  	
  	{
  		return context;
  	}
}

void context_item(Context context_) throws ZamiaException:
{
	ArrayList<Name> l;
}
{
	( library_clause(context_)
	| l = use_clause()
		{
			int n = l.size();
			for (int i = 0; i<n; i++) {
				Name name = l.get(i);
				context_.addUse (name);
			}
		}
	)
}

void library_clause(Context context_) throws ZamiaException :
{
	Identifier id;
	Token t;
}
{
	t = <LIBRARY>  id=identifier() { context_.addLibrary(id.getImage(), getLocation(t)); } 
	( <COMMA> id=identifier() { context_.addLibrary(id.getImage(), id.getLineCol()); } )* <SEMICOLON>
}

ArrayList<Name> use_clause() throws ZamiaException :
{
	ArrayList<Name> l = new ArrayList<Name>();
	Name n;
}
{
	<USE> n = name() { l.add(n);}
	( <COMMA> n = name() { l.add(n); } )* <SEMICOLON>
	{ return l ; }
}

DesignUnit library_unit(Context context_)  throws ZamiaException:
{	DesignUnit lu;
}
{
    ( LOOKAHEAD(<ENTITY> | <CONFIGURATION> | <PACKAGE> identifier() )
		lu = primary_unit(context_)
	| lu = secondary_unit(context_)
	)
	{ return lu; }
}

PrimaryUnit primary_unit(Context context_) throws ZamiaException:
{
	Entity entity;
	VHDLPackage pkg;
	PrimaryUnit pu = null;
}
{
	{ if (dump) System.out.println (">>>>>>> primary_unit"); }
	( entity = entity_declaration(context_)
		{ pu = entity; }
	| configuration_declaration(context_)
	| LOOKAHEAD(<PACKAGE> identifier())
		pkg = package_declaration(context_)
		{  pu = pkg; }
 	)
	{ if (dump) System.out.println ("<<<<<<< primary_unit");
		return pu;
	}
}

Entity entity_declaration(Context context_) throws ZamiaException :
{
	Identifier id, id2=null;
	Entity entity;
	Token t;
}
{
	t=<ENTITY> id = identifier() <IS>
  
	{
	  	entity = new Entity(context_, id.getImage(), sf, getLocation (t), lib, zdb);
	}
  
	entity_header(entity)
    entity_declarative_part(entity)
    [ <BEGIN> entity_statement_part(entity) ]
	<END> [ <ENTITY> ] [ id2=identifier() ] <SEMICOLON>
  
	{
		if (id2 != null && !id2.equals(id)) {
		    id2.setParent(entity);
			erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id+"')", id2.getLocation()));
		} 
		return entity;
	}
}

void entity_statement_part(Entity entity_) throws ZamiaException :
{}
{
	( entity_statement(entity_) )*
}

void entity_statement(Entity entity_) throws ZamiaException:
{
	ConcurrentStatement stmt;
}
{   
	( LOOKAHEAD( concurrent_assertion_statement() )
		stmt = concurrent_assertion_statement()
	| LOOKAHEAD([identifier() <COLON>] [<POSTPONED>] <PROCESS>)
		stmt = process_statement()
	| stmt = concurrent_procedure_call_statement()
	)
	{
		entity_.add(stmt);
	}
}


void entity_declarative_part(Entity entity_) throws ZamiaException:
{
	AttributeDeclaration ad;
	TypeDeclaration type;
	SubProgram sub;
    ArrayList<ConstantDeclaration> lcd;	
    ArrayList<SharedVariableDeclaration> lsv;
    ArrayList<SignalDeclaration> lsd;	
    BlockDeclarativeItem item;
    AliasDeclaration aliasDecl;
}
{
	(sub = subprogram()
		{
			entity_.add(sub);
		}
	| type = type_declaration()
		{
			entity_.add(type);
		}
	| type = subtype_declaration()
		{
			entity_.add(type);
		}
		
	| lcd = constant_declaration() 
		{
			int n = lcd.size();
            for (int i = 0; i<n; i++) {
                    ConstantDeclaration c = lcd.get(i);
                    entity_.add(c); 
            }
        }
		
    | lsd = signal_declaration()
		{
			n = lsd.size();
            for (int i = 0; i<n; i++) {
                    SignalDeclaration s = lsd.get(i);
                    entity_.add(s); 
            }
        }
    | lsv = shared_variable_declaration()
		{
			n = lsv.size();
            for (int i = 0; i<n; i++) {
                    SharedVariableDeclaration svd = lsv.get(i);
                    entity_.add(svd); 
            }
        }
//  | file_declaration()
    | aliasDecl = alias_declaration()
    	{
    		entity_.add(aliasDecl);
    	}
	|	LOOKAHEAD(attribute_declaration())
		ad = attribute_declaration()
		{
			entity_.add(ad);
		}
	| attribute_specification()
//  | disconnection_specification()
//  | use_clause()
	| LOOKAHEAD(<GROUP> identifier() <IS>)		item = group_template_declaration()
		{ entity_.add(item); }	| item = group_declaration()
		{entity_.add(item);}

    )*
}


void entity_header(Entity entity_) throws ZamiaException :
{
	InterfaceList ports;
	InterfaceList generics = null;
	int n;
}
{
  [ generics = generic_clause() 
    {
    	entity_.setGenerics(generics);
    }
  ]
  [ ports = port_clause() 
    {
    	entity_.setPorts(ports);
    }
  ]
}

ConfigurationDeclaration configuration_declaration(Context context_) throws ZamiaException:
{
	Identifier id, id2=null;
	Name entityName;
	ConfigurationDeclaration cd;
	Token t;	
}
{
	t=<CONFIGURATION> id=identifier() <OF> entityName=name() <IS>
		{ cd = new ConfigurationDeclaration (context_, id.getImage(), entityName, sf, getLocation(t), lib, zdb); }
		( configuration_declarative_item(cd) )*
		block_configuration()
	<END> [ <CONFIGURATION> ] [ id2=identifier() ] <SEMICOLON>
	{ 
		if (id2 != null && !id2.equals(id)) {
		    id2.setParent(cd);
			erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id+"')", id2.getLocation()));
		} 
		
		return cd; 
	}
}

void configuration_declarative_item(ConfigurationDeclaration cd_) throws ZamiaException:
{
	// AttributeSpecification as;
	// GroupDeclaration gd;
	ArrayList<Name> l;
}
{
	try {
		
		l = use_clause()
			{
				int n = l.size();
				for (int i = 0; i<n; i++) {
					Name name = l.get(i);
					cd_.getContext().addUse (name);
				}
			}
		| attribute_specification()
		| group_declaration()
		
	} catch(ParseException e) {
		error_skipto(SEMICOLON, "syntax error in configuration declarative item",e);
	}
}

void attribute_specification() throws ZamiaException :
{}
{
	<ATTRIBUTE> identifier() <OF>
	entity_specification() <IS> expression() <SEMICOLON>
}

void entity_specification() throws ZamiaException :
{}
{
	entity_name_list() <COLON> entity_class()
}

void entity_name_list() throws ZamiaException :
{}
{
	( entity_designator() ( <COMMA> entity_designator() )*
	| <OTHERS>
	| <ALL>
	)
}

void entity_designator() throws ZamiaException :
{}
{
	entity_tag() [ signature() ]
}

void entity_tag() throws ZamiaException :
{}
{
	( identifier ()
	| <character_literal>
	| <string_literal>
	)
}

void entity_class() throws ZamiaException :
{}
{
	( <ENTITY> 
	| <ARCHITECTURE> 
	| <CONFIGURATION> 
	| <PROCEDURE> 
	| <FUNCTION> 
	| <PACKAGE> 
	| <TYPE> 
	| <SUBTYPE> 
	| <CONSTANT> 
	| <SIGNAL> 
	| <VARIABLE> 
	| <COMPONENT> 
	| <LABEL> 
	| <LITERAL> 
	| <UNITS> 
	| <GROUP> 
	| <FILE> 
	)
}

void entity_class_entry() throws ZamiaException :
{}
{
  entity_class() [ <BOX> ]
}


void entity_class_entry_list()  throws ZamiaException :
{}
{
  entity_class_entry() ( <COMMA> entity_class_entry() )*
}


void block_configuration() throws ZamiaException :
{}
{
	<FOR> name()
		( use_clause() )*
		( configuration_item() )*
	<END> <FOR> <SEMICOLON>
}

void configuration_item() throws ZamiaException:
{}
{
	LOOKAHEAD(block_configuration())
		block_configuration()
	| component_configuration()
}

void component_configuration() throws ZamiaException:
{}
{
	<FOR> component_specification()
		[ binding_indication() <SEMICOLON> ]
		[ block_configuration() ]
	<END> <FOR> <SEMICOLON>
}

ComponentSpecification component_specification() throws ZamiaException:
{
	ArrayList<Identifier> il;
	Name n;
}
{
	il = instantiation_list() <COLON> n = name()
	{
		return new ComponentSpecification(il, n, il.get(0).getLineCol());
	}	
}

ArrayList<Identifier> instantiation_list() throws ZamiaException:
{
	ArrayList<Identifier> ids = new ArrayList<Identifier>();
	Identifier id;
	Token t;
}
{
	(
	id = identifier() { ids.add(id); }
	( <COMMA> id = identifier() { ids.add(id); })*
	| t = <OTHERS> { ids.add(new Identifier("OTHERS", false, getLocation(t))); }
	| t = <ALL> { ids.add(new Identifier("ALL", false, getLocation(t))); }
	)
	{
		return ids;
	}
}


BindingIndication binding_indication() throws ZamiaException:
{
	BindingIndication bi = null;
	EntityAspect ea;
	Token t;
	AssociationList al;
}
{
	[ t=<USE> ea = entity_aspect() 
	  {
	  	bi = new BindingIndication(getLocation(t));
	  	bi.setEntityAspect(ea);
	  }
	]
	[ al = generic_map_aspect()
	  {
	  	if (bi == null) {
	  		bi = new BindingIndication(al.getAssociation(0).getLineCol());
	  	}
	  	bi.setGenericMapAspect(al);
	  } 
	]
	[ al = port_map_aspect() 
	  {
	  	if (bi == null) {
	  		bi = new BindingIndication(al.getAssociation(0).getLineCol());
	  	}
	  	bi.setPortMapAspect(al);
	  } 
	]
	{
		return bi;
	}
}

EntityAspect entity_aspect() throws ZamiaException:
{
	EntityAspect ea=null;
	Name n;
	Token t;
	Identifier id;
}
{
	( t=<ENTITY> n=name()
	  {
	  	ea = new EntityAspect(EntityAspectKind.Entity, n, getLocation(t));
	  }
		 [ LOOKAHEAD(<LPAREN> identifier() <RPAREN>)
			<LPAREN> id=identifier() <RPAREN> {ea.setId(id.getImage());} ]
	| t=<CONFIGURATION> n=name()
	  {
	  	ea = new EntityAspect(EntityAspectKind.Configuration, n, getLocation(t));
	  }
	| t=<OPEN>
	  {
	  	ea = new EntityAspect(EntityAspectKind.Open, null, getLocation(t));
	  }
	)
	{
		return ea;
	}
}

VHDLPackage package_declaration(Context context_) throws ZamiaException:
{
	Identifier id,id2=null;
	VHDLPackage pkg;
	Token t;
}
{
	t = <PACKAGE> id = identifier() <IS>
		{ pkg = new VHDLPackage (context_, id.getImage(), sf, getLocation(t), lib, zdb); }
		( package_declarative_item(pkg) )*
	<END> [ <PACKAGE> ] [ id2=identifier() ] <SEMICOLON>
	{ 
		if (id2 != null && !id2.equals(id)) {
		    id2.setParent(pkg);
			erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id+"')", id2.getLocation()));
		} 
		return pkg; 
	}
}

void package_declarative_item(VHDLPackage pkg_) throws ZamiaException:
{
	TypeDeclaration type;
	ComponentDeclaration comp;
	ArrayList<Name> l;
	ArrayList<SignalDeclaration> lsd;
	ArrayList<ConstantDeclaration> lcd;
	ArrayList<FileDeclaration> lfd;
	ArrayList<SharedVariableDeclaration> lsv;
	AttributeDeclaration ad;
	SubProgram sub;
	BlockDeclarativeItem item;
}
{
	try {
	(sub = subprogram() { pkg_.add(sub); }
	| type = type_declaration() { pkg_.add(type); }
	| type = subtype_declaration() { pkg_.add(type); }
	| lcd = constant_declaration() 
		{
			int n = lcd.size();
			for (int i = 0; i<n; i++) {
				ConstantDeclaration c = lcd.get(i);
				pkg_.add(c); 
			}
		}
	| lsd = signal_declaration() 
		{
			n = lsd.size();
			for (int i = 0; i<n; i++) {
				SignalDeclaration sd = lsd.get(i);
			
				pkg_.add(sd); 
			}
		}
	| lsv = shared_variable_declaration()
		{
			n = lsv.size();
			for (int i = 0; i<n; i++) {
				SharedVariableDeclaration sd = lsv.get(i);
				pkg_.add(sd); 
			}
		}
	| lfd = file_declaration()
		{
			n = lfd.size();
			for (int i = 0; i<n; i++) {
				FileDeclaration fd = lfd.get(i);
				pkg_.add(fd);
			}
		}

	| item = alias_declaration()
		{
			pkg_.add(item);
		} 
	| comp = component_declaration() {pkg_.add(comp); }
	| LOOKAHEAD( attribute_declaration() )
		ad = attribute_declaration()
		{pkg_.add(ad);}
	| attribute_specification()
		//FIXME { pkg_.add(item); }
	| item = disconnection_specification()
		{ pkg_.add(item); }
	| l = use_clause()
		{
			n = l.size();
			for (int i = 0; i<n; i++) {
				Name name = l.get(i);
			
				pkg_.getContext().addUse(name); 
			}
		}
	| LOOKAHEAD(<GROUP> identifier() <IS>)
		item = group_template_declaration()
		{ pkg_.add(item); }
	| item = group_declaration()
		{ pkg_.add(item); }
	)
	}
	catch(ParseException e)
	{
		error_skipto(SEMICOLON, "syntax error in package declarative item:",e);
	}
}


InterfaceList port_clause()  throws ZamiaException :
{
	InterfaceList ports;
}
{
	<PORT> <LPAREN> ports = interface_list(InterfaceContext.PORT, OIDir.LINKAGE) <RPAREN> <SEMICOLON>
  
	{
		return ports;
	}
}

InterfaceList interface_list(InterfaceContext ic_, OIDir defaultDir_) throws ZamiaException:
{
	InterfaceList interfaces;
	ArrayList<InterfaceDeclaration> ids;
}
{
  ids = interface_declaration(ic_, defaultDir_) 
  { 
  	interfaces = new InterfaceList(null, ids.get(0).getLineCol());
  	int n = ids.size();
  	for (int i = 0; i<n; i++) {
  		interfaces.add(ids.get(i));
  	} 
  }
  
  ( (<COMMA> | <SEMICOLON>) [ids = interface_declaration(ic_, defaultDir_) 
  { 
  	n = ids.size();
  	for (int i = 0; i<n; i++) {
  		interfaces.add(ids.get(i));
  	} 
  } ] )*
  
  {
  	return interfaces;
  }
}

ArrayList<InterfaceDeclaration> interface_declaration(InterfaceContext ic_, OIDir defaultDir_) throws ZamiaException:
{
	ArrayList<InterfaceDeclaration> idds;
	ArrayList<Identifier> ids;
	IGObjectCat kind = null;
	TypeDefinition td;
	OIDir dir = defaultDir_;
	Operation op = null;
}
{
	
	[ (<FILE> { kind = IGObjectCat.FILE; }
	  | <VARIABLE> { kind = IGObjectCat.VARIABLE; }
	  | <CONSTANT> { kind = IGObjectCat.CONSTANT; }
	  | <SIGNAL> { kind = IGObjectCat.SIGNAL; }  ) ] ids = identifier_list() <COLON>
	[ dir = mode() ] 
	
	{
		if (kind == null) {
			
			switch (ic_) {
			case FUNCTION:
				if (dir != OIDir.IN) {
					erm.addError (new ZamiaException ("Function parameters must have mode IN.", ids.get(0).getLocation()));
				}
				if (kind == null) {
					kind = IGObjectCat.CONSTANT;
				} else {
					if (kind == IGObjectCat.VARIABLE) {
						erm.addError (new ZamiaException ("Function parameters must be signals, constants or files.", ids.get(0).getLocation()));
					}
				}
				break;
			case PROCEDURE:
				if (kind == null) {
					if (dir == OIDir.IN) {
						kind = IGObjectCat.CONSTANT;
					} else {
						kind = IGObjectCat.VARIABLE;
					}
				}
				break;
			case PORT:
				if (kind == null) {
					kind = IGObjectCat.SIGNAL;
				}
				break;
			case GENERIC:
				if (kind == null) {
					kind = IGObjectCat.CONSTANT;
				} else {
					if (kind == IGObjectCat.CONSTANT) {
						erm.addError (new ZamiaException ("Generics must be constants.", ids.get(0).getLocation()));
					}
				}
				break;				
			}
		}
	}
	
	td = subtype_indication() [ <BUS> ] [ <ASSIGN> op = expression() ]
  
	{
		int num = ids.size();
		idds = new ArrayList<InterfaceDeclaration>(num);  	
		for (int i = 0; i<num; i++) {
			Identifier id = ids.get(i);
  		
			InterfaceDeclaration isd = new InterfaceDeclaration (id.getImage(), td, dir, op, kind, null, id.getLineCol());
			idds.add(isd);  		
		}
  	
		return idds;
	}
}

OIDir mode() throws ZamiaException :
{ 
	OIDir m = OIDir.LINKAGE;
}
{
	(  <IN> { m = OIDir.IN; }
	| <OUT> { m = OIDir.OUT; }
	| <INOUT> { m = OIDir.INOUT; }
	| <BUFFER> { m = OIDir.BUFFER; }
	| <LINKAGE> { m = OIDir.LINKAGE; }
	)
	{ return m ; }
}

SecondaryUnit secondary_unit(Context context_) throws ZamiaException:
{
	SecondaryUnit su = null;
}
{
	{if (dump) System.out.println ("secondary_unit"); }
	
	( su = architecture_body(context_) 
	| su = package_body(context_)
	)
	{ return su; }
}

PackageBody package_body(Context context_) throws ZamiaException:
{
	Identifier id, id2=null;
	Token t;
	PackageBody body;
}
{
	t=<PACKAGE> <BODY> id = identifier() <IS>
		{
				body = new PackageBody(context_, id.getImage(), sf, getLocation(t), lib, zdb);
		}
		package_body_declarative_part(body)
	<END> [ <PACKAGE> <BODY> ] [ id2=identifier() ] <SEMICOLON>
	{ 
		if (id2 != null && !id2.equals(id)) {
		    id2.setParent(body);
			erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id+"')", id2.getLocation()));
		} 
		
		return body;
	}
}

void package_body_declarative_item(PackageBody body_) throws ZamiaException:
{
	SubProgram sub = null;
	TypeDeclaration td = null;
	ConstantDeclaration cd = null;
	ArrayList<Name> l;
	ArrayList<ConstantDeclaration> l2;
	ArrayList<FileDeclaration> l3;
	ArrayList<SharedVariableDeclaration> lsv;
	BlockDeclarativeItem item;
}
{
	(sub = subprogram() {body_.add(sub);}
	| td = type_declaration() { body_.add(td); }
	| td = subtype_declaration() {body_.add(td); }
	| l2 = constant_declaration() 
	      {
	          int n = l2.size();
    	      for (int i = 0; i<n; i++) {
	    	      ConstantDeclaration c = l2.get(i);
            	  body_.add(c);
	          }
	      }
	| lsv = shared_variable_declaration()
	      {
	          n = lsv.size();
    	      for (int i = 0; i<n; i++) {
	    	      SharedVariableDeclaration sd = lsv.get(i);
            	  body_.add(sd);
	          }
	      }
    | l3 = file_declaration()
	      {
	          n = l3.size();
    	      for (int i = 0; i<n; i++) {
	    	      FileDeclaration fd = l3.get(i);
            	  body_.add(fd);
	          }
	      }
    | item = alias_declaration()
    	{
    		body_.add(item);
    	}
	| l = use_clause()
	      {
	          n = l.size();
    	      for (int i = 0; i<n; i++) {
	    	      Name name = l.get(i);
            	  body_.getContext().addUse (name);
	          }
	      }
	| LOOKAHEAD(<GROUP> identifier() <IS>)
		item = group_template_declaration()
		{ body_.add(item); }
	| item = group_declaration() 
		{ body_.add(item); }
	)
}

void package_body_declarative_part(PackageBody body_)  throws ZamiaException:
{}
{
	( package_body_declarative_item(body_) )*
}



Architecture architecture_body(Context context_)  throws ZamiaException:
{
	Identifier id, id2=null;
	Name entityName;
	Architecture arch;
	Token t;
}
{
	t = <ARCHITECTURE> id = identifier() <OF> entityName = name() <IS> 
		{ arch= new Architecture (context_, id.getImage(), entityName, zprj, sf, getLocation(t), lib, zdb);	}
		architecture_declarative_part(arch)
	try {
		<BEGIN>
			architecture_statement_part(arch)
		<END> [ <ARCHITECTURE> ] [ id2 = identifier() ] <SEMICOLON>
	} catch(ParseException e) {
		error_skipto(SEMICOLON, "syntax error in architecture",e);
	}
	{ 
		if (id2 != null) {
			if (!id2.equals(id)) {
			  id2.setParent(arch);
			  erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id+"')", id2.getLocation()));
			}
		} 
		return arch; 
	}
}

void architecture_declarative_part(Architecture arch_) throws ZamiaException:
{
	ArrayList<BlockDeclarativeItem> l;
	BlockDeclarativeItem item;
}
{
	( l = block_declarative_item() 
		{
			int n = l.size();
			for (int i = 0; i<n; i++) {
				item = l.get(i);
				arch_.add (item);
			}
		}
	)*
}

ArrayList<BlockDeclarativeItem> block_declarative_item() throws ZamiaException :
{
	ArrayList<BlockDeclarativeItem> l = new ArrayList<BlockDeclarativeItem>();
	ArrayList<ConstantDeclaration> lcd;
	ArrayList<SignalDeclaration> lsd;
	ArrayList<FileDeclaration> lfd;
	ArrayList<SharedVariableDeclaration> lsv;
	ArrayList<ConfigurationSpecification> lcs;
	ArrayList<Name> uc;
	BlockDeclarativeItem item;
	int n;
}
{
	( item = subprogram() { l.add(item); }
	| item = type_declaration() { l.add (item); }
	| item = subtype_declaration() { l.add (item); }
	| lcd = constant_declaration()
	{
		n = lcd.size();
		for (int i = 0; i<n; i++) {
			l.add(lcd.get(i));
		}
	}
	| lsd = signal_declaration()
	{
		n = lsd.size();
		for (int i = 0; i<n; i++) {
			l.add(lsd.get(i));
		}
	}
	| lsv = shared_variable_declaration()
	{
		n = lsv.size();
		for (int i = 0; i<n; i++) {
			l.add(lsv.get(i));
		}
	}
	| lfd = file_declaration()
	{
		n = lfd.size();
		for (int i = 0; i<n; i++) {
			l.add(lfd.get(i));
		}
	}
	| item = alias_declaration()
		{
			l.add(item);
		}
	| item = component_declaration() { l.add (item); }
	| LOOKAHEAD(attribute_declaration())
		item = attribute_declaration()
		{ l.add(item); }
	| attribute_specification()
	| lcs = configuration_specification()
	{
		n = lcs.size();
		for (int i = 0; i<n; i++) {
			l.add(lcs.get(i));
		}
	}
	| item = disconnection_specification()
		{ l.add(item); }
	| uc = use_clause()
	{
		n = uc.size();
		for (int i = 0; i<n; i++) {
			Name name = uc.get(i);
			l.add(new Use(name, null, name.getLineCol()));
		}
	}
	| LOOKAHEAD(<GROUP> identifier() <IS>)
	  item = group_template_declaration()
	  { l.add(item); }
	| item = group_declaration()
	  { l.add(item); }
	)
  { return l; }
}

void architecture_statement_part(Architecture arch_)  throws ZamiaException:
{
	ConcurrentStatement stmt;
}
{
	( 
	  try {
	    stmt = architecture_statement(arch_) 
	    {
	    	if (stmt != null) {
	    		arch_.add(stmt);
	    	}
	    }
	  } catch(ParseException e) {
		error_skipto(SEMICOLON, "syntax error in architecture statement part.",e);
	  }
	   
	)*
}

ConcurrentStatement architecture_statement(Architecture arch_) throws ZamiaException:
{
	ConcurrentStatement stmt=null;
}
{
	(
	LOOKAHEAD([identifier() <COLON>] <BLOCK>)
		stmt = block_statement()
	| LOOKAHEAD([identifier() <COLON>] [<POSTPONED>] <PROCESS>)
		stmt = process_statement() 
	| LOOKAHEAD([identifier() <COLON>] [<POSTPONED>] procedure_call() <SEMICOLON>)
	 	stmt = concurrent_procedure_call_statement()
	| LOOKAHEAD(concurrent_assertion_statement())
		stmt = concurrent_assertion_statement()
//	| LOOKAHEAD([identifier() <COLON>] [<POSTPONED>] conditional_signal_assignment()|//		[identifier() <COLON>] [<POSTPONED>] selected_signal_assignment())//		stmt = concurrent_signal_assignment_statement()
	| LOOKAHEAD([identifier() <COLON>] [<POSTPONED>] target() <LE> |
		[identifier() <COLON>] [<POSTPONED>] <WITH>)
		stmt = concurrent_signal_assignment_statement()
	| LOOKAHEAD(identifier() <COLON> instantiated_unit() )
		stmt = component_instantiation_statement()
//	| LOOKAHEAD(generate_statement())
	| LOOKAHEAD(identifier() <COLON> generation_scheme() <GENERATE>)
		stmt = generate_statement()

	/** 1076.1 extensions: */
	// FIXME | LOOKAHEAD(concurrent_break_statement())
	// FIXME 	concurrent_break_statement()
	// FIXME | simultaneous_statement()
	
	/** 1076-2008 extensions: */
	| LOOKAHEAD( [ identifier() <COLON>] <ASSERT> | psl_psl_directive()) 
	  psl_psl_directive()
	)
  { return stmt; }
}

ConcurrentProcedureCall concurrent_procedure_call_statement() throws ZamiaException:
{
	ConcurrentProcedureCall stmt;
	Name n;
	boolean isPostponed = false;
	Identifier label = null;
	String sLabel = null;
}
{
	[ LOOKAHEAD( identifier() <COLON>) label = identifier() <COLON> { sLabel = label.getImage(); } ]
	[ <POSTPONED> { isPostponed = true; } ] 
	
	n = name() <SEMICOLON>

	{ 
		stmt = new ConcurrentProcedureCall (n, sLabel, null, n.getLineCol());
		stmt.setPostponed(isPostponed);
		return stmt; 
	}
}


Block block_statement() throws ZamiaException :
{
	Identifier id, id2=null;
	Operation guard = null;
	Block block;
	BlockDeclarativeItem item;
	ArrayList l;
}
{
	id = identifier() <COLON>
	<BLOCK> [ <LPAREN> guard = expression() <RPAREN> ] [ <IS> ]
	{ block = new Block (id.getImage(), guard, null, id.getLineCol()); }
		block_header(block)
		( l = block_declarative_item() 
			{ 
				int n = l.size();
				for (int i = 0; i<n; i++) {
					item = (BlockDeclarativeItem) l.get(i);
					block.add(item);
				}
			} )*
	<BEGIN>
		block_statement_part(block)
	<END> <BLOCK> [ id2 = identifier() ] <SEMICOLON>
	{ 
		if (id2 != null) {
			if (!id2.equals(id)) {
			  id2.setParent(block);
			  erm.addError (new ZamiaException ( "Closing id doesn't match (was expecting '"+id+"')", id2.getLocation()));
			}
		} 
		return block; 
	}
}

void block_header(Block block_) throws ZamiaException :
{
	AssociationList l = null;
	InterfaceList l2 = null;
}
{
	[ l2 = generic_clause() { block_.setGenerics (l2); }
		[ l = generic_map_aspect() <SEMICOLON> { block_.setGenericMap(l); } ] ]
	[ l2 = port_clause() { block_.setPorts (l2); }
		[ port_map_aspect() <SEMICOLON> { block_.setPortMap (l); } ] ]
}

void block_statement_part(Block block) throws ZamiaException:
{
	ConcurrentStatement stmt;
}
{
	( stmt = architecture_statement(null) {block.add(stmt);} )*
}


InstantiatedUnit instantiated_unit(Identifier id_) throws ZamiaException:
{
	InstantiatedUnit iu = null;
	Name n;
	Identifier id=null;
}
{
	(
	[ <COMPONENT> ] n = name() { iu = new ComponentInstantiation (id_.getImage(), n, null, n.getLineCol()); }
	| <ENTITY> n = name() [ <LPAREN> id = identifier() <RPAREN> ] { iu = new EntityInstantiation (id_.getImage(), n, id != null ? id.getImage() : null, null, n.getLineCol()); }
	| <CONFIGURATION> n = name() { iu = new ConfigurationInstantiation (id_.getImage(), n, null, n.getLineCol()); }
	)
	{ return iu; }
}

InstantiatedUnit component_instantiation_statement() throws ZamiaException:
{
	Identifier id;
	InstantiatedUnit iu;
	AssociationList l;
}
{
	id = identifier() <COLON> iu = instantiated_unit(id)
		[ l = generic_map_aspect() 
			{
				iu.setGenericMapAspect(l);
			}
		]
		[ l = port_map_aspect() 
			{
				iu.setPortMapAspect(l);
			}	
		] <SEMICOLON>
	{ return iu; }
}

AssociationList port_map_aspect()  throws ZamiaException :
{
	AssociationList l;
}
{
	<PORT> <MAP> <LPAREN> l=association_list() <RPAREN>
	{ return l; }
}

AssociationList generic_map_aspect() throws ZamiaException :
{
	AssociationList l;
}
{
	<GENERIC> <MAP> <LPAREN> l = association_list() <RPAREN>
	{
		return l;
	}
}

AssociationList association_list()  throws ZamiaException :
{
	AssociationList l;
	AssociationElement ae;
}
{
	ae = association_element() { l = new AssociationList(null, ae.getLineCol()); l.add(ae); }
	( <COMMA> ae=association_element() { l.add(ae); } )*
	{ return l; }
}

AssociationElement association_element()  throws ZamiaException :
{
	AssociationElement ae;
	Operation op;
	FormalPart fp = null;
}
{
	[ LOOKAHEAD( formal_part() <FOLLOWS> ) fp = formal_part() <FOLLOWS>  ]
	op = actual_part()
	{
		if (fp != null) {
			ae = new AssociationElement (null, fp.getLineCol()); 
			ae.setFormalPart(fp);
		} else if (op != null) {
			ae = new AssociationElement (null, op.getLineCol()); 
		} else { // OPEN
			ae = new AssociationElement (null, 0); 
		}
		ae.setActualPart (op);
		return ae;
	}
}

FormalPart formal_part() throws ZamiaException :
{
	Name n1, n2;
	FormalPart fp;
}
{
	( LOOKAHEAD( name() <LPAREN> name() <RPAREN>)
		n1 = name() <LPAREN> n2 = name() <RPAREN> { fp = new FormalPart(n1, null, n1.getLineCol()); fp.setName2 (n2); }
	| n1 = name() {  fp = new FormalPart(n1, null, n1.getLineCol()); }
	)
	{ return fp; }
}

Operation actual_part()  throws ZamiaException :
{
	Operation op;
}
{
	// FIXME: really neccessary? expression 
	// expands to function call and type conversion...
	//( LOOKAHEAD( name() <LPAREN> actual_designator() <RPAREN>)
	//	name() <LPAREN> actual_designator() <RPAREN>
	//| actual_designator()
	//)
	
	op = actual_designator()
	{ return op; }
}

Operation actual_designator() throws ZamiaException :
{
	Operation op = null;
}
{
	( <OPEN>
	| op = expression()
	)
	{ return op; }
}

ConditionalSignalAssignment conditional_signal_assignment() throws ZamiaException:
{
	Target target;
	ArrayList wv;
	ConditionalSignalAssignment csa;
	long location;
}
{
	
	target = target() 
	{
		csa = new ConditionalSignalAssignment (target, null, target.getLineCol());
	}
	
	<LE> options_(csa) wv=conditional_waveforms() <SEMICOLON>
	
	{
		int n = wv.size();
		for (int i = 0; i<n; i++) {
			ConditionalWaveform cw = (ConditionalWaveform) wv.get(i);
			csa.add(cw);
		}
		return csa;
	}
}

void options_(ConcurrentSignalAssignment csa_) throws ZamiaException:
{
	DelayMechanism dm;
}
{
	[ <GUARDED> { csa_.setGuarded(true);} ] 
	[ dm = delay_mechanism() { csa_.setDelayMechanism(dm); } ]
}

DelayMechanism delay_mechanism() throws ZamiaException :
{
	boolean isInertial = true;
	Operation reject = null;
	Token t = null;
	Token t2=null;
}
{
	( t=<TRANSPORT> { isInertial = false;}
	| [ t=<REJECT> reject=expression() ] t2=<INERTIAL> { if (t==null) t = t2; }
	)
	{ 
		return new DelayMechanism(isInertial, reject, null, getLocation(t)); 
	}
}

Target target() throws ZamiaException :
{
	Name name;
	Aggregate aggregate;
}
{
	( name = name() { return new Target(name, null, name.getLineCol()); }
	| aggregate = aggregate()  { return new Target(aggregate, null, aggregate.getLineCol()); }
	)
}

ArrayList<ConditionalWaveform> conditional_waveforms() throws ZamiaException :
{
	Waveform w;
	ArrayList<ConditionalWaveform> l = new ArrayList<ConditionalWaveform>();
	ConditionalWaveform cw;
	Operation cond;
}
{
	w = waveform()
	{ cw = new ConditionalWaveform (w, null, w.getLineCol()); }
	( LOOKAHEAD( <WHEN> expression() <ELSE>)
		<WHEN> cond = expression() <ELSE> w = waveform() 
		{ cw.setCond(cond); l.add (cw); cw = new ConditionalWaveform (w,null,w.getLineCol()); }		
	)*
    [ <WHEN> cond = expression() { cw.setCond(cond);}  ]
    {
    	l.add (cw);
    	return l;
    }
}

Waveform waveform() throws ZamiaException :
{
	Waveform w;
	WaveformElement we;
	long location;
	Token t;
}
{
	( we=waveform_element() 
		{ 
			w = new Waveform(null, we.getLineCol()); 
			w.add(we);
		}
		( <COMMA> we=waveform_element() { w.add(we); } )*
	| t=<UNAFFECTED>
		{
			w = new Waveform(null, getLocation(t)); 
			w.setUnaffected(true);
		}
	)
	{ return w; }
}

WaveformElement waveform_element() throws ZamiaException :
{
	Operation value=null;
	Operation after=null;
	long location;
	Token t = null;
}
{
	( LOOKAHEAD(<NULL>)
		t=<NULL> [<AFTER> after=expression() ]
	| value = expression() [ <AFTER> after = expression() ] 
	)
	
	{ 
		if (t != null)
			location = getLocation(t);
		else
			location = value.getLineCol();
		return new WaveformElement (value, after, null, location); 
	}
}

ConcurrentStatement concurrent_assertion_statement() throws ZamiaException :
{
	Assertion ass;
	long location;
	Token t=null;
	Identifier id=null;
	boolean isPostponed=false;
	ConcurrentAssertion ca;
}
{
	[ id = identifier() <COLON> ] [ t=<POSTPONED> { isPostponed = true; }] ass = assertion() <SEMICOLON>
	
	{
		location = ass.getLineCol();
		if (id != null)
			location = id.getLineCol();
		else if (t != null) {
			location = getLocation(t);
		}
		ca = new ConcurrentAssertion(ass, null, location);
		ca.setPostponed(isPostponed);
		return ca;
	}
}

ConcurrentSignalAssignment concurrent_signal_assignment_statement() throws ZamiaException :
{
	//String id;
	ConcurrentSignalAssignment stmt;
	boolean postponed = false;
	Identifier label=null;
}
{
	[ LOOKAHEAD( identifier() <COLON>) label=identifier() <COLON> ]
	[ <POSTPONED> { postponed = true; } ]
//	( LOOKAHEAD(  target() <LE> options_() conditional_waveforms() <SEMICOLON>)
	( LOOKAHEAD(  target() <LE> )
	stmt = conditional_signal_assignment()
	| stmt = selected_signal_assignment() )
	{
		stmt.setPostponed(postponed); 
		if (label != null) {
			stmt.setLabel(label.getImage());
		}
		return stmt; 
	}
}

SelectedSignalAssignment selected_signal_assignment() throws ZamiaException :
{
	Operation expr;
	Target target;
	ArrayList<SelectedWaveform> waveforms;
	Token t;
	SelectedSignalAssignment ssa;
}
{
	t=<WITH> expr=expression() <SELECT>
	target = target()  
	{
		ssa = new SelectedSignalAssignment (expr, target, null, getLocation(t));
	}
	
	<LE> options_(ssa) waveforms=selected_waveforms() <SEMICOLON>
	
	{
		int n = waveforms.size();
		for (int i = 0; i<n; i++) {
		
			SelectedWaveform wf = waveforms.get(i);
			ssa.add (wf);
		}
		return ssa;
	}		
}

ArrayList<SelectedWaveform> selected_waveforms() throws ZamiaException :
{
	ArrayList<SelectedWaveform> l = new ArrayList<SelectedWaveform>();
	SelectedWaveform sw;
	Waveform w;
	ArrayList<Range> choices;
}
{
	w=waveform() <WHEN> choices = choices()
	
	{
		sw = new SelectedWaveform (w, choices, null, w.getLineCol());
		l.add(sw);
	}
	
	(<COMMA> w=waveform() <WHEN> choices = choices() 
		{
			sw = new SelectedWaveform (w, choices, null, w.getLineCol());
			l.add(sw);
		}
	)*
	
	{ return l; }
}


GenerateStatement generate_statement() throws ZamiaException :
{
	GenerateStatement gs;
	ConcurrentStatement stmt;
	Identifier label, id2=null;
	ArrayList<BlockDeclarativeItem> decls;
}
{
	label = identifier() <COLON>
	gs = generation_scheme(label) <GENERATE>
		[ LOOKAHEAD(2) ( decls = block_declarative_item() { gs.add(decls); } )* <BEGIN> ]
		//[ LOOKAHEAD((block_declarative_item())* <BEGIN>) ( block_declarative_item() )* <BEGIN> ]
		( stmt = architecture_statement(null) { gs.add(stmt);})*
	<END> <GENERATE> [ id2 = identifier() ] <SEMICOLON>
	{
		if (id2 != null && !id2.equals(label)) {
		    id2.setParent(gs);
			erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+label+"')", id2.getLocation()));
		} 
		return gs; 
	}
}

GenerateStatement generation_scheme(Identifier label_) throws ZamiaException :
{
	GenerateStatement gs = null;
	Identifier id;
	Range range;
	Operation exp;
	Token t;
	Name n;
}
{
	( t = <FOR> id = identifier() <IN> (LOOKAHEAD(range()) range = range() | n = name() {  range = new Range(n, null, n.getLineCol());})
		{ gs = new GenerateStatement (id.getImage(), range, label_.getImage(), null, label_.getLineCol()); }
	| t = <IF> exp = expression()
		{ gs = new GenerateStatement (exp, label_.getImage(), null, label_.getLineCol()); }
	)
	{ return gs ; }
}



ArrayList<ConstantDeclaration> constant_declaration() throws ZamiaException :
{
	ArrayList<ConstantDeclaration> res;
	ArrayList<Identifier> ids;
	TypeDefinition type;
	Operation value=null;
}
{
	<CONSTANT> ids=identifier_list() <COLON> type=subtype_indication()
	[ <ASSIGN> value=expression() ] <SEMICOLON>
	{
		int n = ids.size();
		res = new ArrayList<ConstantDeclaration> (n);
		for (int i = 0; i<n; i++) {
			Identifier id = ids.get(i);
			res.add (new ConstantDeclaration (id.getImage(), type, value, null, id.getLineCol()));
		}
		return res;
	}
}

ArrayList<SignalDeclaration> signal_declaration() throws ZamiaException :
{
	ArrayList<Identifier> ids;
	TypeDefinition type;
	int kind = SignalDeclaration.KIND_NONE;
	Operation value=null;
	ArrayList<SignalDeclaration> res;
}
{
	<SIGNAL> ids = identifier_list() <COLON>
	type = subtype_indication() [ kind = signal_kind() ] [ <ASSIGN> value=expression() ] <SEMICOLON>
	{
		int n = ids.size();
		res = new ArrayList<SignalDeclaration>(n);
		for (int i = 0; i<n; i++) {
			Identifier id = ids.get(i);
			res.add (new SignalDeclaration (id.getImage(), type, kind, value, null, id.getLineCol()));
		}
		return res;
	}
}

ArrayList <SharedVariableDeclaration> shared_variable_declaration() throws ZamiaException :
{
	ArrayList<Identifier> ids;
	TypeDefinition type;
	Operation value=null;
	ArrayList<SharedVariableDeclaration> res;
}
{
	[ <SHARED> ] <VARIABLE> ids = identifier_list() <COLON>
	type = subtype_indication() [ <ASSIGN> value = expression() ] <SEMICOLON>
	{
		int n = ids.size();
		res = new ArrayList<SharedVariableDeclaration>(n);
		for (int i = 0; i<n; i++) {
			Identifier id = ids.get(i);
			res.add (new SharedVariableDeclaration (id.getImage(), type, value, null, id.getLineCol()));
		}
		return res;
	}
}


int signal_kind() throws ZamiaException :
{}
{
	( <REGISTER> { return SignalDeclaration.KIND_REGISTER; }
	| <BUS> { return SignalDeclaration.KIND_BUS; }
	)	
}

ComponentDeclaration component_declaration() throws ZamiaException :
{
	ComponentDeclaration comp;
	Identifier id, id2 = null;
	InterfaceList l;
	Token t;
}
{
	t=<COMPONENT> id = identifier() [ <IS> ]
	{ comp = new ComponentDeclaration (id.getImage(), null, getLocation(t)); }
	[ l = generic_clause() 
		{
			comp.setGenerics(l);
		}
	]
	[ l = port_clause() 
		{
			comp.setInterfaces(l);
		}
	]
	<END> <COMPONENT> [ id2 = identifier() ] <SEMICOLON>
	
	{
		if (id2 != null) {
			if (!id2.equals(id)) {
			  id2.setParent(comp);
			  erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id+"')", id2.getLocation()));
			}
		} 
		 
		return comp; 
	}
}

InterfaceList generic_clause() throws ZamiaException :
{
	InterfaceList l;
}
{
	<GENERIC> <LPAREN> l = interface_list(InterfaceContext.GENERIC, OIDir.IN) <RPAREN> <SEMICOLON>
	{ return l; }
}


TypeDeclaration type_declaration() throws ZamiaException :
{
	TypeDeclaration td = null;
	Identifier id;
	Token t;
}
{
	(  LOOKAHEAD( <TYPE> identifier() <IS> )
		td = full_type_declaration()
	| t=<TYPE> id = identifier() <SEMICOLON>
		{
			td = new TypeDeclaration(id.getImage(), new TypeDefinitionIncomplete(null, getLocation(t)), null, getLocation(t));
		}
	)
	
	{ return td; }
}

TypeDeclaration full_type_declaration() throws ZamiaException :
{
	Identifier id;
	TypeDefinition td;
	Token t;
}
{
	t=<TYPE> id = identifier() <IS> td = type_definition() <SEMICOLON>
	
	{ return new TypeDeclaration (id.getImage(), td, null, getLocation(t)); }
}

TypeDeclaration subtype_declaration() throws ZamiaException :
{
	Identifier id;
	TypeDefinition type;
	Token t;
}
{
	t=<SUBTYPE> id = identifier() <IS> type = subtype_indication() <SEMICOLON>
	{ return new TypeDeclaration (id.getImage(), type, null, getLocation(t)); }
}

AttributeDeclaration attribute_declaration() throws ZamiaException :
{
	Identifier id;
	Name type;
}
{
	<ATTRIBUTE> id = identifier() <COLON> type = name() <SEMICOLON>
	
	{ return new AttributeDeclaration (id.getImage(), type, null, id.getLineCol()); }
}

TypeDefinitionSubType subtype_indication() throws ZamiaException :
{
	Name resf = null;
	Name name;
	ArrayList constr = null;
}
{
	[ LOOKAHEAD (name() name()) resf = name() ] name = name() [ constr = constraint() ]
   
	{
		TypeDefinitionSubType td = new TypeDefinitionSubType(name, null, name.getLineCol());

		td.setResolutionFunction(resf);
		td.setConstraint (constr);
		
		return td;
	}
}

TypeDefinition type_definition() throws ZamiaException :
{
	TypeDefinition td;
}
{
	( td = scalar_type_definition()
	| td = composite_type_definition()
	| td = access_type_definition()
	| td = file_type_definition()
	| td = protected_type_definition()
	)
	{ return td; }
}

TypeDefinition scalar_type_definition() throws ZamiaException :
{
	TypeDefinition td;
	Range range;
}
{
	( LOOKAHEAD(range_constraint() <UNITS> )
	td = physical_type_definition()
//	| LOOKAHEAD(enumeration_type_definition())
	| LOOKAHEAD(<LPAREN>)
    td = enumeration_type_definition()
	/* integer_type_definition / floating_type_definition: */
	| range = range_constraint()
		{   td = new TypeDefinitionRange (range, null, range.getLineCol()); }	
	)
	{ return td; }
}

TypeDefinitionAccess access_type_definition() throws ZamiaException :
{
	TypeDefinition td;
	Token t;
}
{
	t=<ACCESS> td = subtype_indication()
	{ return new TypeDefinitionAccess (td, null, getLocation(t)); }
}

TypeDefinitionFile file_type_definition() throws ZamiaException:
{
	Name name;
	Token t;
}
{
	t=<FILE> <OF> name = name()
	{ return new TypeDefinitionFile (name, null, getLocation(t)); }
}

TypeDefinitionPhysical physical_type_definition() throws ZamiaException :
{
	TypeDefinitionPhysical tdp;
	Range range;
	String unit;
}
{
	range = range_constraint()
	<UNITS>
	unit = base_unit_declaration()
	{ tdp = new TypeDefinitionPhysical(range, unit, null, range.getLineCol());}
	( secondary_unit_declaration(tdp) )*
  	<END> <UNITS> [ identifier() ]
  	{ return tdp; }
}

String base_unit_declaration() throws ZamiaException :
{
	Identifier unit;
}
{
	unit = identifier() <SEMICOLON>
	{ return unit.getImage(); }
}

void secondary_unit_declaration(TypeDefinitionPhysical td_) throws ZamiaException :
{
	Identifier id;
	OperationLiteral pl;
}
{
	id = identifier() <EQ> pl=physical_literal() <SEMICOLON>
	{ td_.addUnit (id.getImage(), pl, id.getLineCol()); }
}


TypeDefinitionEnum enumeration_type_definition() throws ZamiaException :
{
	TypeDefinitionEnum td;
	long location;
	OperationLiteral l;
}
{
	<LPAREN> l = enumeration_literal() 
		{ 
			td = new TypeDefinitionEnum (null, l.getLineCol());
			td.add(l);
		} 
		( <COMMA> l = enumeration_literal() { td.add(l);}  )* <RPAREN>
	{ return td; }
}



TypeDefinition composite_type_definition() throws ZamiaException :
{
	TypeDefinition td;
}
{
	( td = array_type_definition()
	| td = record_type_definition()
	)
	{ return td; }
}

TypeDefinition array_type_definition() throws ZamiaException :
{
	TypeDefinition td;
}
{
	( LOOKAHEAD(<ARRAY> <LPAREN> index_subtype_definition())
	td = unconstrained_array_definition()
	| td = constrained_array_definition()
	)
	{ return td; }
}

TypeDefinitionUnconstrainedArray unconstrained_array_definition() throws ZamiaException :
{
	TypeDefinitionUnconstrainedArray td;
	Name isd;
	TypeDefinition elementType;
	Token t;
}
{
	t = <ARRAY> <LPAREN> isd = index_subtype_definition()
	{ td = new TypeDefinitionUnconstrainedArray (null, getLocation(t)); td.add(isd); }
	( <COMMA> isd = index_subtype_definition() { td.add (isd); } )* 
	<RPAREN>
	<OF> elementType = subtype_indication()
	
	{
		td.setElementType (elementType);
		return td;
	}
}

Name index_subtype_definition() throws ZamiaException :
{
	Name n;
}
{
	n = name() <RANGE> <BOX>
	{ return n; }
}

TypeDefinitionConstrainedArray constrained_array_definition() throws ZamiaException :
{
	TypeDefinitionConstrainedArray td;
	TypeDefinition std;
	ArrayList<DiscreteRange> constraints;
	Token t;
}
{
	t=<ARRAY> constraints = index_constraint() <OF> std = subtype_indication()
  
	{
	  	td = new TypeDefinitionConstrainedArray (std, null, getLocation(t));
	  	int n = constraints.size();
	  	for (int i = 0; i<n; i++)
	  		td.add (constraints.get(i));
	  	return td;
	}
}

TypeDefinitionRecord record_type_definition() throws ZamiaException :
{
	TypeDefinitionRecord td;
	Token t;
}
{
	t = <RECORD>
	{ 
		td = new TypeDefinitionRecord (null, getLocation(t));
	}
		( element_declaration(td) )+
	<END> <RECORD> [ identifier() ]
	{ return td; }
}

void element_declaration(TypeDefinitionRecord td_) throws ZamiaException :
{
	ArrayList<Identifier> ids;
	TypeDefinition type;
}
{
	ids = identifier_list() <COLON> type=subtype_indication() <SEMICOLON>
	
	{ 
		int n = ids.size();
		for (int i = 0; i<n; i++) {
			Identifier id = ids.get(i);
			td_.addElement (id.getImage(), type, id.getLineCol());
		}
	}
}

ArrayList<DiscreteRange> constraint() throws ZamiaException :
{
	ArrayList<DiscreteRange> ranges;
	Range range;
}
{
	(
    	range = range_constraint() 
    	{ ranges = new ArrayList<DiscreteRange>(1); ranges.add (new DiscreteRange(range, null, range.getLineCol()));}
	| ranges = index_constraint()
	)
	{ return ranges; }
}

ArrayList<DiscreteRange> index_constraint() throws ZamiaException :
{
	ArrayList<DiscreteRange> ranges = new ArrayList<DiscreteRange> (1);
	DiscreteRange dr;
}
{
	<LPAREN> dr = discreteRange() { ranges.add (dr); }
	( <COMMA> dr = discreteRange() { ranges.add(dr);}  )* <RPAREN>
	{ 
		return ranges; 
	}
}

DiscreteRange discreteRange() throws ZamiaException :
{
	Range range;
	TypeDefinitionSubType td;
}
{
	( LOOKAHEAD(simple_expression() direction() )
		range = range() {return new DiscreteRange (range, null, range.getLineCol());}
	| LOOKAHEAD (name() name() constraint()) 		
		td = subtype_indication() { return new DiscreteRange (td, null, td.getLineCol()); }
	| LOOKAHEAD (name() constraint()) 		
		td = subtype_indication() { return new DiscreteRange (td, null, td.getLineCol()); }
	| LOOKAHEAD (name() name()) 		
		td = subtype_indication() { return new DiscreteRange (td, null, td.getLineCol()); }
	| LOOKAHEAD (name()) 		
		td = subtype_indication() { return new DiscreteRange (td, null, td.getLineCol()); }
//	| LOOKAHEAD( subtype_indication() )//		td = subtype_indication() { return new DiscreteRange (td, null, l); }
	| range = range() {return new DiscreteRange (range, null, range.getLineCol());}
	)
}



Range range_constraint() throws ZamiaException :
{
	Range range;
	Name n;
}
{
	<RANGE> (LOOKAHEAD(range()) range = range() | n = name() {range = new Range(n, null, n.getLineCol());})
	{ return range; }
}

Range range() throws ZamiaException :
{
	Name name;
	Operation left, right;
	int dir;
}
{
	(		LOOKAHEAD (simple_expression() direction() )
		left = simple_expression() dir = direction() right = simple_expression()
		
		{ return new Range (left, dir, right, null, left.getLineCol()); }
	|  		name = name() { return new Range (name, null, name.getLineCol()); }
	)
}

int direction() throws ZamiaException :
{}
{
	( <TO>  { return Range.DIR_UP; } | <DOWNTO> { return Range.DIR_DOWN; } )
}

Operation simple_expression() throws ZamiaException :
{ 
	Operation res = null, t;
	boolean do_invert = false;
	boolean do_pos = false;
	long l;
	MathOp op = MathOp.ADD;
	boolean is_concat = false;
	Token token = null;
}
{
	[ ( token=<ADD> { do_pos = true; } | token=<SUB> { do_invert = true; } ) ] res = term()
	{   
		if (do_invert) {
			res = new OperationMath(MathOp.NEG, res, null, getLocation(token));
		} else if (do_pos) {
			res = new OperationMath(MathOp.POS, res, null, getLocation(token));
		}
	}		
   
   
//	(LOOKAHEAD(4)
	(LOOKAHEAD (<ADD> | <SUB> | <CONCAT>)
		( 
		token=<ADD> { op = MathOp.ADD; is_concat = false;}
		| token=<SUB> { op = MathOp.SUB; is_concat = false;}
		| token=<CONCAT> { is_concat = true; }
		)

		t = term() 
		{
			if (!is_concat) {
				res = new OperationMath(op, res, t, null, getLocation(token));
			} else {
				res = new OperationConcat(res, t, null, getLocation(token));
			}
		}
    )*

	{   
		return res;
	}
}


Operation term() throws ZamiaException :
{ 
	Operation res;
	Operation f;
	MultiplyingOperator mo;
}
{
	res = factor() 
	(LOOKAHEAD(4)
		mo = multiplying_operator() 
		f = factor()
		{ res = new OperationMath(mo.getOp(), res, f, null, mo.getLineCol()); }
	)*
	
	{ return res; }
}

MultiplyingOperator multiplying_operator() throws ZamiaException :
{
	Token t;
}
{
	( 
	t=<MUL>     { return new MultiplyingOperator(MathOp.MUL, getLocation(t)); }
	| t=<DIV>     { return new MultiplyingOperator(MathOp.DIV, getLocation(t)); }
	| t=<MOD>   { return new MultiplyingOperator(MathOp.MOD, getLocation(t)); }
	| t=<REM>   { return new MultiplyingOperator(MathOp.REM, getLocation(t)); }
	)
}

Operation factor() throws ZamiaException :
{
	Operation res;
	Operation p;
	Token t;
}
{
	(
		t= <ABS> p = primary() {res = new OperationMath(MathOp.ABS, p, null, getLocation(t)); }
		| t=<NOT> p = primary() {res = new OperationLogic(LogicOp.NOT, p, null, null, getLocation(t), getLocation(t)); }
		| res = primary() 
			[ LOOKAHEAD(<EXP> primary()) t=<EXP> p = primary() 
				{ 
					res = new OperationMath(MathOp.POWER, res, p, null, getLocation(t)); 
				}
			]
	)
  
  { return res; }
}

Name name() throws ZamiaException:
{
	Identifier id;
	Name name;
	//Token t;
	Signature signature = null;
	Token t;
	String img;
}
{

	(
	id = identifier() 
	  { img = id.getImage(); 
		name = new Name(id.getImage(), null, id.getLineCol());
	  }
	| t = <string_literal>
		{ name = new Name(t.image.toUpperCase(), null, getLocation(t));}
	)

	[ LOOKAHEAD(<LBRACKET>) signature = signature() ]

	[ LOOKAHEAD( (<LPAREN> | <PERIOD> | <TICK> )) name_extension(name, signature) ]
	
	{ return name; }
}

Name operation_call() throws ZamiaException:
{
	Name name;
	Signature signature = null;
	Token t;
}
{

	t = <string_literal>
	{ name = new Name(t.image.toUpperCase(), null, getLocation(t));}

	[ LOOKAHEAD(<LBRACKET>) signature = signature() ]

	[ LOOKAHEAD( (<LPAREN> | <PERIOD> | <TICK> )) name_extension(name, signature) ]
	
	{ return name; }
}

Name pure_name() throws ZamiaException:
{
	Identifier id;
	Name name;
	Signature signature = null;
}
{

	id = identifier()
	{ name = new Name(id.getImage(), null, id.getLineCol());}

	[ LOOKAHEAD(<LBRACKET> ( identifier() | <RETURN> )  ) signature = signature() ]

	[ LOOKAHEAD( (<LPAREN> | <PERIOD> | <TICK> )) name_extension(name, signature) ]
	
	{ return name; }
}

void name_extension(Name name, Signature signature_) throws ZamiaException:
{
	Identifier id;
	Operation exp = null;
	Suffix suffix;
	Range range;
	NameExtensionIndex nameExtensionIndex;
	NameExtensionRange nameExtensionRange;
	Token t;
	Aggregate aggregate;
	AssociationList al=null;	
}
{
	(
	  LOOKAHEAD(<TICK> <RANGE> )
		t=<TICK> <RANGE>
		[ LOOKAHEAD( <LPAREN> expression() <RPAREN>) <LPAREN> exp = expression() <RPAREN>]
		{
			name.add (new NameExtensionAttribute ("RANGE", signature_, exp, null, getLocation(t)));
		}
	| LOOKAHEAD(<TICK> identifier()) t = <TICK> id=identifier()
		[ LOOKAHEAD( <LPAREN> expression() <RPAREN>) <LPAREN> exp = expression() <RPAREN>]
		{
			name.add (new NameExtensionAttribute (id.getImage(), signature_, exp, null, getLocation(t)));
		}
	| LOOKAHEAD(<TICK>)
		t = <TICK> aggregate = aggregate()
		{
			if (!aggregate.isAggregate()) {
				exp = aggregate.getElement(0).getExpression();
				exp.setParent(null, true);
			    name.add (new NameExtensionQualifiedExpression(exp, null, getLocation(t)));
			} else {
				name.add (new NameExtensionQualifiedExpression(aggregate, null, getLocation(t)));
			}
		}
	| t = <PERIOD> suffix = suffix()
		{
			name.add (new NameExtensionSuffix (suffix, null, getLocation(t)));
		}
	| LOOKAHEAD( <LPAREN> range() (<COMMA> range() )* <RPAREN> )
		t = <LPAREN> range = range() { nameExtensionRange = new NameExtensionRange(range, null, getLocation(t)); }
		(<COMMA> range = range() {nameExtensionRange.add (range);} )* <RPAREN>
		{
			name.add (nameExtensionRange);
		}
	| LOOKAHEAD( <LPAREN> expression() (<COMMA> expression() )* <RPAREN>) 
		t = <LPAREN> exp = expression() { nameExtensionIndex = new NameExtensionIndex(exp, null, getLocation(t));  }
	        (<COMMA> exp = expression() { nameExtensionIndex.add (exp); } )* <RPAREN>
		{
			name.add (nameExtensionIndex);
		}
	| t = <LPAREN> al=association_list() <RPAREN> 
		{
			name.add(new NameExtensionFunctionCall(al, null, getLocation(t)));
		}
	)
  [  LOOKAHEAD( (<TICK> | <PERIOD> | <LPAREN> ) ) name_extension(name, null) ]
}

Signature signature() throws ZamiaException :
{
	Signature signature;
	Name n;
}
{
	<LBRACKET>
	{ signature = new Signature (null, getLocation()); }
	
	( LOOKAHEAD(identifier())
		n = name() { signature.add (n); }
		( LOOKAHEAD (<COMMA> name() ) <COMMA> n = name() { signature.add (n); } )*
		[ LOOKAHEAD (<RETURN>) <RETURN> n = name() { signature.setReturn (n);}]
	| <RETURN> n = name() { signature.setReturn (n);}
	)
	<RBRACKET>
	{ return signature; }
}

Operation expression() throws ZamiaException :
{ 
	Operation res, op;
	LogicOp lo;
	Token t;
}
{
	res = relation()
	( LOOKAHEAD(1) 
		( t=<AND>     { lo = LogicOp.AND; }
		| t=<OR>      { lo = LogicOp.OR; }
		| t=<NAND>    { lo = LogicOp.NAND; }
		| t=<NOR>     { lo = LogicOp.NOR; }
		| t=<XOR>     { lo = LogicOp.XOR; }
		| t=<XNOR>    { lo = LogicOp.XNOR; }
		)
		op = relation() 
		{
			res = new OperationLogic(lo, res, op, null, res.getLineCol(), getLocation(t));
		}
	)*

	{ 
		return res;
	}
}

LogicOp logical_operator():
{}
{
	<AND>     	{ return LogicOp.AND; }
	| <OR>      { return LogicOp.OR; }
	| <NAND>    { return LogicOp.NAND; }
	| <NOR>     { return LogicOp.NOR; }
	| <XOR>     { return LogicOp.XOR; }
	| <XNOR>    { return LogicOp.XNOR; }
}

Operation relation() throws ZamiaException :
{ 
	Operation res, o;
	CompareOp op;
	long opLoc;
}
{
	res = shift_expression() 
	[ op = relational_operator() { opLoc = getLocation(token); } o = shift_expression() 
	  { res = new OperationCompare(op, res, o, null, res.getLineCol(), opLoc); }
	]
	
	{return res;}
}

CompareOp relational_operator():
{}
{
    <EQ>                { return CompareOp.EQUAL; }
  | <NEQ>               { return CompareOp.NEQUAL; }
  | <LO>                { return CompareOp.LESS; }
  | <LE>                { return CompareOp.LESSEQ; }
  | <GT>                { return CompareOp.GREATER; }
  | <GE>                { return CompareOp.GREATEREQ; }
}

Operation shift_expression() throws ZamiaException :
{ 
	Operation res, o;
	ShiftOp op;
}
{
	res = simple_expression() 
	[ 
	  op = shift_operator() o = simple_expression() 
	  
	  { res = new OperationShift(op, res, o, null, res.getLineCol()); }
	]
	
	{ return res; }
}

ShiftOp shift_operator() throws ZamiaException :
{}
{
    <SLL>               { return ShiftOp.SLL; }
  | <SRL>               { return ShiftOp.SRL; }
  | <SLA>               { return ShiftOp.SLA; }
  | <SRA>               { return ShiftOp.SRA; }
  | <ROL>               { return ShiftOp.ROL; }
  | <ROR>               { return ShiftOp.ROR; }
}

Operation primary() throws ZamiaException :
{
	Operation res;
	Name n;
	Aggregate aggregate;
}
{
	( LOOKAHEAD(<NEW>) res = allocator()
	| LOOKAHEAD(<string_literal> <LPAREN>)
		n = operation_call() { res = new OperationName(n, null, n.getLineCol()); }
	| LOOKAHEAD(numeric_literal() | <character_literal> | <string_literal> | <bit_string_literal> | <NULL>)
		res = pure_literal()
	| LOOKAHEAD(identifier())
		n = pure_name() { res = new OperationName(n, null, n.getLineCol()); }
	| aggregate = aggregate()
		{
			if (!aggregate.isAggregate()) {
				res = aggregate.getElement(0).getExpression();
				res.setParent(null, true);
			} else { 
				res = new OperationAggregate (aggregate, null, aggregate.getLineCol());
			} 
		}
	)
	{ return res; }
}

OperationAllocator allocator() throws ZamiaException:
{
	TypeDefinitionSubType td = null;
	Token t;
}
{
	t=<NEW>
	td=subtype_indication()
	
	{
		return new OperationAllocator(td, null, getLocation(t));
	}
}


OperationLiteral literal() throws ZamiaException :
{
	OperationLiteral res;
	Token t;
}
{
	(
	LOOKAHEAD( numeric_literal() )
	res = numeric_literal()
	| res = enumeration_literal()
	| t = <bit_string_literal> 
		{ 
			String str = t.image.toUpperCase();
			int len = str.length(); 
			res = new OperationLiteral (str, LiteralCat.BIT_STRING, null, getLocation(t)); 
		}
	| t = <string_literal> 
		{ 
			str = t.image.toUpperCase();
			len = str.length(); 
			res = new OperationLiteral (str.substring(1,len-1), LiteralCat.STRING, null, getLocation(t)); 
		}
	| t=<NULL> { res = new OperationLiteral (null, LiteralCat.NULL, null, getLocation(t)); }
	)
	{ return res; }
}

// since enumeration_literal also contains identifier which is also covered by name,
// we create this "pure" literal production for primaries:
OperationLiteral pure_literal() throws ZamiaException :
{
	OperationLiteral res;
	Token t;
}
{
	(
		LOOKAHEAD( numeric_literal() )
		res = numeric_literal()
		
 	| t=<character_literal>
 		{ 
			res = new OperationLiteral (""+t.image.charAt(1), LiteralCat.CHAR, null, getLocation(t)); 
 		}
	| t = <bit_string_literal> 
		{ 
			res = new OperationLiteral (t.image.toUpperCase(), LiteralCat.BIT_STRING, null, getLocation(t)); 
		}
	| t = <string_literal> 
		{ 
			String str = t.image.toUpperCase();
			int len = str.length(); 
			res = new OperationLiteral (str.substring(1,len-1), LiteralCat.STRING, null, getLocation(t)); 
		}
	| t=<NULL> { res = new OperationLiteral (null, LiteralCat.NULL, null, getLocation(t)); }
	)
	{ return res; }
}

OperationLiteral numeric_literal() throws ZamiaException :
{
	OperationLiteral res;
}
{
	( LOOKAHEAD (physical_literal())
	res = physical_literal()
	| res = abstract_literal() )
	{ return res; }
}

OperationLiteral physical_literal() throws ZamiaException :
{
	Name n;
	OperationLiteral l = null;
}
{
	l = abstract_literal() 
	n = name()
	{ 
		if (l == null)
			return new OperationLiteral (n.getId(), LiteralCat.STRING, null, n.getLineCol());
		return new OperationLiteral (l, n, null, l.getLineCol()); 
	}
}

OperationLiteral abstract_literal() throws ZamiaException :
{
	OperationLiteral res;
	long location;
	Token t;
}
{
	( t = <decimal_literal>
		{ res = new OperationLiteral (t.image, LiteralCat.DECIMAL, null, getLocation(t)); }
	| t = <based_literal>
		{ res = new OperationLiteral (t.image, LiteralCat.BASED, null, getLocation(t)); }
	)
	{ return res; }
}

OperationLiteral enumeration_literal() throws ZamiaException :
{
	OperationLiteral res;
	Token t=null;
	Identifier id;
}
{
	( t = <character_literal>
		{ res = new OperationLiteral (""+t.image.charAt(1), LiteralCat.CHAR, null, getLocation(t)); }
		// also covered by name:
	| id = identifier()		{ res = new OperationLiteral (id.getImage(), LiteralCat.ENUM, null, id.getLineCol()); }
	)
	{ return res; }
}

Aggregate aggregate() throws ZamiaException :
{
	Aggregate agg;
	ElementAssociation ea;
}
{
	{ agg = new Aggregate (null, getLocation()); }
	<LPAREN> ea = element_association() {agg.add (ea);} 
	( <COMMA> ea = element_association() {agg.add (ea);} )* <RPAREN>
	{ return agg ;}
}

ElementAssociation element_association() throws ZamiaException :
{
	ArrayList<Range> choices = null;
	Operation op=null,se=null,exp=null;
	long location;
	Range r;
	Token t;
	int dir;
}
{
  ( t = <OTHERS> { choices = new ArrayList<Range>(); choices.add(null); location = getLocation(t);}
  | op = expression() { location = op.getLineCol(); }
    [ LOOKAHEAD (direction()) dir=direction() se=simple_expression() 
	    {
	    	r = new Range (op, dir, se, null, op.getLineCol());
	    	choices = new ArrayList<Range>(); choices.add(r);
	    	op = null;
	    }
	]
  )

  ( <PIPE> r = choice() 
      {
      	 if (choices == null) {
      		choices = new ArrayList<Range>();
      		choices.add(new Range (op, op, false, null, op.getLineCol()));
      		op = null;
      	 }
      	 choices.add(r);
      } 
  )*

  [ <FOLLOWS> exp = expression() ]

  {
  	if (exp == null) {
  		if (choices != null || op == null) {
  			throw new ZamiaException("Syntax error in element assocation: choices given but no expression.", new SourceLocation(sf, location));
  		}
  		exp = op;
  	} else {
  		if (choices == null){
  			if (op == null) {
  				throw new ZamiaException("Syntax error in element assocation: expression given but no choices.", exp.getLocation());
  			}
	   		choices = new ArrayList<Range>();
   			choices.add(new Range (op, op, false, null, op.getLineCol()));
  		}
  	}
  	
  	
	return new ElementAssociation (choices, exp, null, location); 
  }
}

ArrayList<Range> choices() throws ZamiaException :
{
	ArrayList<Range> l = new ArrayList<Range>(1);
	Range r;
}
{
	r = choice() { l.add(r);}
	( <PIPE> r = choice() { l.add(r);} )*
	{ return l; }
}


Range choice() throws ZamiaException :
{
	Operation op,se;
	int dir;
}
{
	(<OTHERS>
		{ return null; }
	| op = simple_expression()
        
        [ LOOKAHEAD(direction())
          dir = direction()
          se = simple_expression()
          {
	    	return new Range (op, dir, se, null, op.getLineCol());
          }
        ]	
	
		{ return new Range (op, op, false, null, op.getLineCol()); }
	)
}

Suffix suffix() throws ZamiaException :
{
	Suffix suffix=null ;
	Identifier id;
	Token t;
}
{
	(
		id = identifier() 
		{ 
			suffix = new Suffix (id.getLineCol()); 
			suffix.setId (id.getImage()); 
		}
	| t=<character_literal>
		{ 
			suffix = new Suffix (getLocation(t)); 
			suffix.setCharLiteral (t.image.charAt(1)); 
		}
	| t = <string_literal>
		{ 
			suffix = new Suffix (getLocation(t)); 
			suffix.setStringLiteral (t.image.toUpperCase()); 
		}
	| t=<ALL>
		{ 
			suffix = new Suffix (getLocation(t)); 
			suffix.setAll(); 
		}
	)
	
	{ return suffix; }
}

Identifier identifier() throws ZamiaException :
{ 
	Token t; 
	Identifier id;
	boolean extended = false;

}
{  
	(  t=<basic_identifier> 
	|  t=<extended_identifier> { extended = true; }
	)
	{
		id = new Identifier(t.image.toUpperCase(), extended, getLocation(t)); 
		return id;
	}
}

ArrayList<Identifier> identifier_list() throws ZamiaException :
{
	ArrayList<Identifier> ids = new ArrayList<Identifier>();
	Identifier id;
}
{
	id = identifier() { ids.add(id); }
	( <COMMA> id=identifier() {ids.add (id);} )*
  
	{ return ids; }
}

/**
 * processes
 */
 
SequentialProcess process_statement() throws ZamiaException :
{
	SequentialProcess proc;
	ArrayList l;
	SequenceOfStatements seq;
	Token t;
	String label = null;
	Identifier id1 = null, id2 = null;
	boolean isPostponed = false;
}
{
	[ id1 = identifier() <COLON> { label = id1.getImage(); } ]
	[ <POSTPONED> { isPostponed = true; } ] t=<PROCESS> 
	{ 
		proc = new SequentialProcess (null, getLocation(t));
		proc.setPostponed(isPostponed);
		if (label != null)  {
			proc.setLabel(label);
		}
	}
	[ <LPAREN> l = sensitivity_list() <RPAREN> 
		{
			int n = l.size();
			for (int i = 0; i<n; i++) {
				Name name = (Name) l.get(i);
				proc.addSensitivity (name);
			}
		}
	] [ <IS> ]
		( process_declarative_item(proc) )*
	<BEGIN>
		seq = sequence_of_statements()
		{ proc.setStatementSequence (seq); }
	<END> [ <POSTPONED> ] <PROCESS> [ id2 = identifier() ] <SEMICOLON>
	{ 
		if (id2 != null) {
		    id2.setParent(proc);
			if (id1 == null) {
				  erm.addError (new ZamiaException ("No label given at start of process.", id2.getLocation()));
			} else {
				if (!id2.equals(id1)) {
				  erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id1+"')", id2.getLocation()));
				}
			}
		} 
		return proc; 
	}
}

ArrayList<Name> sensitivity_list() throws ZamiaException :
{
	Name n;
	ArrayList<Name> l = new ArrayList<Name>(1);
}
{
	n = name() { l.add (n); } 
	( <COMMA> n = name() { l.add (n); } )*
	{ return l; }
}

void process_declarative_item(SequentialProcess proc_) throws ZamiaException :
{
	TypeDeclaration td;
	ArrayList<ConstantDeclaration> lcd;
	ArrayList<FileDeclaration> lfd;
	ArrayList<VariableDeclaration> lvd;
	ArrayList<Name> ln;
	AttributeDeclaration ad;
	SubProgram sub;
	BlockDeclarativeItem item;
}
{
	( sub = subprogram() { proc_.add(sub); }
	| td = type_declaration() { proc_.add(td); }
	| td = subtype_declaration() { proc_.add(td); }
	| lcd = constant_declaration()
		{
			int n = lcd.size();
			for (int i = 0; i<n; i++) {
				item = lcd.get(i);
				proc_.add(item);
			}
		}
	| lvd = variable_declaration()
		{
			n = lvd.size();
			for (int i = 0; i<n; i++) {
				item = lvd.get(i); 
				proc_.add (item);
			}
		}
	| lfd = file_declaration()
		{
			n = lfd.size();
			for (int i = 0; i<n; i++) {
				item = lfd.get(i);
				proc_.add(item);
			}
		}
	| item = alias_declaration() 
	 	{
	 		proc_.add(item);
	 	}
	| LOOKAHEAD( attribute_declaration() )
		ad = attribute_declaration() {proc_.add(ad); }
	| attribute_specification()
	| ln = use_clause() 
		{
			n = ln.size();
			for (int i = 0; i<n; i++) {
				Name name = ln.get(i); 
				proc_.add(new Use (name, null, name.getLineCol()));
			}
		}
	// FIXME | LOOKAHEAD( <GROUP> identifier() <IS> )
	// FIXME   group_template_declaration()
	| group_declaration()
	)
}

ArrayList<FileDeclaration> file_declaration() throws ZamiaException :
{
	ArrayList<FileDeclaration> l;
	ArrayList<Identifier> ids;
	TypeDefinition t;
	FileOpenInformation foi = null;
}
{
	<FILE> ids=identifier_list() <COLON> t=subtype_indication() [ foi = file_open_information() ] <SEMICOLON>
	{ 
		int n = ids.size();
		l = new ArrayList<FileDeclaration>(n);
		for (int i=0; i<n; i++) {
			Identifier id = ids.get(i);
			FileDeclaration fd = new FileDeclaration(id.getImage(), t, foi, null, id.getLineCol());
			l.add (fd);
		}
	  	return l ;
	}
}


FileOpenInformation file_open_information() throws ZamiaException :
{
	Operation exp=null, exp2;
	OIDir m=null;
	Token t=null, t2;
}
{
	// FIXME: VHDL87
	[ t=<OPEN> exp = expression() ] t2=<IS> { if (t==null) t=t2; } [m = mode()] exp2=expression()
	{
		return new FileOpenInformation (exp, m, exp2, null, getLocation(t));
	}
}



ArrayList<VariableDeclaration> variable_declaration() throws ZamiaException :
{
	ArrayList<VariableDeclaration> l;
	ArrayList<Identifier> ids;
	TypeDefinition t;
	Operation exp=null;
}
{
	[ <SHARED> ] <VARIABLE> ids = identifier_list() <COLON>
	t = subtype_indication() [ <ASSIGN> exp = expression() ]
	// FIXME: this is a non-std hack for a big IT vendor
	[ <IS> name() ]  
	<SEMICOLON>
	{ 
		int n = ids.size();
		l = new ArrayList<VariableDeclaration> (n);
		for (int i=0; i<n; i++) {
			Identifier id = ids.get(i);
			VariableDeclaration vd = new VariableDeclaration (id.getImage(), t, exp, null, id.getLineCol());
			l.add (vd);
		}
	  	return l ;
	}
}

SequenceOfStatements sequence_of_statements() throws ZamiaException :
{
	SequenceOfStatements seq=null ;
	SequentialStatement stmt;
}
{
	( stmt = sequential_statement() 
		{ 
			if (stmt != null) {
				if (seq == null)
					seq = new SequenceOfStatements (null, stmt.getLineCol());
				seq.add(stmt); 
			}
		} 
	)*
	{ 
		if (seq == null)
			seq = new SequenceOfStatements (null, getLocation());
		return seq; 
	}
}

SequentialStatement sequential_statement() throws ZamiaException :
{
	SequentialStatement stmt = null;
}
{
	(
		LOOKAHEAD(3)
		stmt = wait_statement()
	| LOOKAHEAD(3)
		stmt = assertion_statement()
	| LOOKAHEAD([identifier() <COLON>] <REPORT>)
	    stmt = report_statement()
	| LOOKAHEAD(  [ identifier() <COLON> ] target() <LE> )
		stmt = signal_assignment_statement()
	| LOOKAHEAD(  [ identifier() <COLON> ] target() <ASSIGN> )
		stmt = variable_assignment_statement()
	| LOOKAHEAD([identifier() <COLON>] name() [ <LPAREN> association_list() <RPAREN> ] <SEMICOLON>)
	    stmt = procedure_call_statement()
	| LOOKAHEAD(3)
		stmt = if_statement()
	| LOOKAHEAD(3)
		stmt = case_statement()
	| LOOKAHEAD(3)
		stmt = loop_statement()
	| LOOKAHEAD(3)
		stmt = next_statement()
	| LOOKAHEAD(3)
	    stmt = exit_statement()
	| LOOKAHEAD(3)
		stmt = return_statement()
	| LOOKAHEAD(3)
		stmt = null_statement()
	)
	{ return stmt; }
}

SequentialNextStatement next_statement() throws ZamiaException:
{
	Token t;
	Identifier id1=null, id2 = null;
	Operation exp = null;
}
{                                                               
	[ id1 = identifier() <COLON> ] t=<NEXT> [ id2 = identifier() ] [ <WHEN> exp = expression() ] <SEMICOLON>
	
	{
		return new SequentialNextStatement ( id2 != null ? id2.getImage() : null, exp, id1 != null ? id1.getImage() : null, null, getLocation(t));
	}
	
}

SequentialReport report_statement() throws ZamiaException  :
{
	Operation exp, severity=null;
	long location;
	Identifier id=null;
	Token t;
	String label = null;
}
{
	[ id = identifier() <COLON> ]  t=<REPORT> exp = expression()
	[ <SEVERITY> severity = expression() ] <SEMICOLON>
  
	{
		location = getLocation(t);
		if (id != null) {
			label = id.getImage();
	  		location = id.getLineCol();
		}
  		return new SequentialReport (exp, severity, label, null, location);
	}
}


SequentialProcedureCall procedure_call() throws ZamiaException:
{
	Name n;
	AssociationList params = null;
}
{
	n = name() 
	{ return new SequentialProcedureCall (n, null, n.getLineCol()); }
}

SequentialProcedureCall procedure_call_statement() throws ZamiaException:
{
	SequentialProcedureCall pc;
}
{
   [ LOOKAHEAD( identifier() <COLON>) identifier() <COLON> ]
   pc = procedure_call() <SEMICOLON>
   { return pc; }
}


SequentialExit exit_statement() throws ZamiaException:
{
	Operation cond = null;
	Token t;
	Identifier l1=null, l2=null;
}
{
  	[ l1=identifier() <COLON> ] t=<EXIT> [ l2=identifier() ]
    [ <WHEN> cond = expression() ] <SEMICOLON>
    {
    	return new SequentialExit (l2 != null ? l2.getImage() : null, cond, l1 != null? l1.getImage():null, null, getLocation(t));
    }
}


SequentialWait wait_statement() throws ZamiaException :
{
	SequentialWait stmt;
	ArrayList l;
	Operation op;
	Token t;
	Identifier label = null;
}
{
	[ LOOKAHEAD( identifier() ) <COLON> label = identifier() <COLON>]
	t = <WAIT> 
	{ 
		stmt = new SequentialWait (label != null ? label.getImage() : null, null, getLocation(t));
	}
	[ l = sensitivity_clause() { stmt.setSensitivityList (l); }]
	[ op = condition_clause() { stmt.setConditionClause (op); }] 
	[ op = timeout_clause() { stmt.setTimeoutClause (op); }] <SEMICOLON>
	{ return stmt; }
}

ArrayList sensitivity_clause() throws ZamiaException :
{
	ArrayList l;
}
{
	<ON> l = sensitivity_list()
	{ return l; }
}

Operation condition_clause() throws ZamiaException :
{
	Operation exp;
}
{
	<UNTIL> exp = expression()
	{ return exp; }
}

Operation timeout_clause() throws ZamiaException :
{
	Operation exp;
}
{
	<FOR> exp = expression()
	{ return exp; }
}


SequentialAssert assertion_statement() throws ZamiaException :
{
	Assertion ass; 
	SequentialAssert stmt;
	Identifier id = null;
	long location;
}
{
	[ id = identifier() <COLON> ] ass = assertion() <SEMICOLON>
	{ 
		location = ass.getLineCol();
		if (id != null)
			location = id.getLineCol();
		return new SequentialAssert(ass, id != null ? id.getImage() : null, null, location); 
	}
}

Assertion assertion() throws ZamiaException :
{
	Assertion assertion;
	Operation op;
	Token t;
}
{
	t = <ASSERT> op = expression()
	{ assertion = new Assertion (op, null, getLocation(t)); }
	[ <REPORT> op = expression() { assertion.setReport (op); } ]
	[ <SEVERITY> op = expression() { assertion.setSeverity (op); } ]
	{ return assertion; }
}

SequentialSignalAssignment signal_assignment_statement() throws ZamiaException :
{
	Target target;
	Waveform waveform;
	DelayMechanism dm=null;
}
{
	[ LOOKAHEAD( identifier() <COLON>) identifier() <COLON> ]
	target = target() <LE> [ dm = delay_mechanism() ] waveform = waveform() <SEMICOLON>
	
	{ return new SequentialSignalAssignment (target, waveform, dm, null, target.getLineCol()); }
}

SequentialVariableAssignment variable_assignment_statement() throws ZamiaException :
{
	Target target; 
	Operation exp;
}
{
	[ LOOKAHEAD( identifier() <COLON>) identifier() <COLON> ]
	target = target() <ASSIGN> exp = expression() <SEMICOLON>
	{ return new SequentialVariableAssignment (target, exp, null, exp.getLineCol()); }
}

SequentialIf if_statement() throws ZamiaException :
{
	Operation cond;
	long location;
	SequenceOfStatements thenStmts, elseStmts;
	SequentialIf stmt, stmt2, stmt3;
	Token t;
	Identifier id1 = null, id2 = null;
}
{
	[ id1 = identifier() <COLON> ]
	t=<IF> cond = expression() <THEN>
		thenStmts = sequence_of_statements()
	{ 
		stmt = new SequentialIf (cond, thenStmts, id1 != null ? id1.getImage() : null, null, getLocation(t)); 
		stmt2 = stmt;
	}
	( t=<ELSIF> cond = expression() <THEN>
		thenStmts = sequence_of_statements() 
		{
			stmt3 = new SequentialIf (cond, thenStmts, null, null, getLocation(t)); 
			
			SequenceOfStatements elseSeq = new SequenceOfStatements(null, getLocation(t));

			elseSeq.add (stmt3);			
			
			stmt2.setElse (elseSeq);
			stmt2 = stmt3;
		}
	)*
	[ <ELSE>
		elseStmts = sequence_of_statements() 
		{
			SequenceOfStatements oldElse = stmt2.getElseStmt();
			if (oldElse == null)
				stmt2.setElse (elseStmts);
			else
				oldElse.append (elseStmts);
		}
	]
	<END> <IF> [ id2 = identifier() ] <SEMICOLON>
	{ 
		if (id2 != null) {
		    id2.setParent(stmt);
			if (id1 == null) {
				  erm.addError (new ZamiaException ("No label given at start of if statement.", id2.getLocation()));
			} else {
				if (!id2.equals(id1)) {
				  erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id1+"')", id2.getLocation()));
				}
			}
		} 
		return stmt; 
	}
}

SequentialCase case_statement() throws ZamiaException :
{
	Operation exp;
	SequentialCase stmt;
	Token t;
	Identifier id1=null, id2=null;	
}
{
	[ id1 = identifier() <COLON> ]
	t = <CASE> exp = expression() <IS>
		{ stmt = new SequentialCase (exp, null, getLocation(t)); }
		case_statement_alternative(stmt)
		( case_statement_alternative(stmt) )*
	<END> <CASE> [ id2 = identifier() ] <SEMICOLON>
	
	{ 
		if (id2 != null) {
		    id2.setParent(stmt);
			if (id1 == null) {
				  erm.addError (new ZamiaException ("No label given at start of statement.", id2.getLocation()));
			} else {
				if (!id2.equals(id1)) {
				  erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id1+"')", id2.getLocation()));
				}
			}
		} 
		return stmt; 
	}
}


void case_statement_alternative(SequentialCase case_) throws ZamiaException :
{
	ArrayList choices;
	SequenceOfStatements seq;
	Token t;
}
{
	t = <WHEN> choices=choices() <FOLLOWS> seq=sequence_of_statements()
	{
		case_.addAlternative (choices, seq, getLocation(t));
	}
}

SequentialLoop loop_statement() throws ZamiaException :
{
	SequentialLoop loop=null;
	SequenceOfStatements seq;
	Token t;
	Identifier id1 = null, id2=null;
	String loopLabel = null;
}
{
	[ id1 = identifier() <COLON> { loopLabel = id1.getImage();}]
	[ loop = iteration_scheme(loopLabel) ] t=<LOOP>
		seq = sequence_of_statements()
		{
			if (loop == null)
				loop = new SequentialLoop (loopLabel, null, getLocation(t));
				 
			loop.setBody (seq); 
		}
	<END> <LOOP> [ id2 = identifier() ] <SEMICOLON>
	{ 
		if (id2 != null) {
		    id2.setParent(loop);
			if (id1 == null) {
				  erm.addError (new ZamiaException ("No label given at start of loop.", id2.getLocation()));
			} else {
				if (!id2.equals(id1)) {
				  erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id1+"')", id2.getLocation()));
				}
			}
		} 
		
		return loop ;
	}
}

SequentialLoop iteration_scheme(String aLoopLabel) throws ZamiaException :
{
	SequentialLoop loop;
	Operation cond;
	Identifier id;
	Range range;
	Token t;
	Name n;
}
{
	( t=<WHILE> cond = expression() { loop = new SequentialWhile (cond, aLoopLabel, null, getLocation(t)); }
	| t=<FOR> id = identifier() <IN> (LOOKAHEAD(range()) range=range() | n = name() {range = new Range(n, null, n.getLineCol());})
		{
			loop = new SequentialFor (id.getImage(), range, aLoopLabel, null, getLocation(t));
		}
	)
	{ return loop; }
}

NullStatement null_statement() throws ZamiaException :
{
	Token t;
}
{
	[ identifier() <COLON> ] t=<NULL> <SEMICOLON>
	{
		return new NullStatement(null, getLocation(t));
	}
}

ReturnStatement return_statement() throws ZamiaException :
{
	Operation exp=null;
	long location;
	Token t;
}
{
	[ identifier() <COLON> ] t=<RETURN> [ exp = expression() ] <SEMICOLON>
	{ return new ReturnStatement (exp, null, getLocation(t)); }
}

/*
 * subprograms
 */

Identifier designator() throws ZamiaException:
{
	Identifier res;
	Token t;
}
{
	( res = identifier()
	| t = <string_literal> { res = new Identifier(t.image.toUpperCase(), false, getLocation(t)); }
	)
	{ return res;}
}

void subprogram_declarative_item(SubProgram sub_)  throws ZamiaException:
{
	ArrayList<VariableDeclaration> l;
	ArrayList<ConstantDeclaration> l2;
	ArrayList<FileDeclaration> l3;
	TypeDeclaration td;
	BlockDeclarativeItem item;
}
{
	( item = subprogram()
		{
			sub_.add(item);
		}
	| td = type_declaration()
		{
			sub_.add(td);
		}
	| td = subtype_declaration()
		{
			sub_.add(td);
		}
	| l2 = constant_declaration()
		{
			int n = l2.size();
			for (int i = 0; i<n; i++) {
				sub_.add(l2.get(i));
			}
		}
	| l = variable_declaration()	
		{
			n = l.size();
			for (int i = 0; i<n; i++) {
				sub_.add(l.get(i));
			}
		}
	| l3 = file_declaration()
		{
			n = l3.size();
			for (int i = 0; i<n; i++) {
				sub_.add(l3.get(i));
			}
		}
	| item = alias_declaration()
		{
			sub_.add(item);
		}
	| LOOKAHEAD(attribute_declaration())
		attribute_declaration() // FIXME
	| attribute_specification() // FIXME
	| use_clause() // FIXME
	//FIXME | LOOKAHEAD( <GROUP> identifier() <IS>)
	//FIXME    group_template_declaration()
	| group_declaration() // FIXME
	)
}

void subprogram_declarative_part(SubProgram sub_) throws ZamiaException :
{}
{
  ( subprogram_declarative_item(sub_) )*
}


void subprogram_statement_part(SubProgram sub_) throws ZamiaException :
{
	SequentialStatement stmt;
	SequenceOfStatements seq = null;
}
{
	{ 
		seq = sub_.getCode(); 
	}
	( stmt = sequential_statement() 
		{ 
			seq.add(stmt); 
		} 
	)*
}

SubProgram subprogram() throws ZamiaException :
{
	Identifier id, id2=null;
	InterfaceList interfaces=null;
	Name n;
	Token t, t2;
	SubProgram sub;
	boolean pure = true;
}
{
	( t=<PROCEDURE> id=designator() [ <LPAREN> interfaces=interface_list(InterfaceContext.PROCEDURE, OIDir.IN) <RPAREN> ]
		{ sub= new SubProgram (id.getImage(), interfaces	, null, false, null, getLocation(t)); }
	| [ <PURE> | <IMPURE> { pure = false; } ] t=<FUNCTION> id=designator()
		[ <LPAREN> interfaces = interface_list(InterfaceContext.FUNCTION, OIDir.IN) <RPAREN> ]
                <RETURN> n = name()
		{ sub = new SubProgram (id.getImage(), interfaces, n, pure, null, getLocation(t)); }
    )
    
    (<IS>
		subprogram_declarative_part(sub)
		t2 = <BEGIN>
			{
				sub.setCode (new SequenceOfStatements(sub, getLocation(t2)));	
			}
			subprogram_statement_part(sub)
		<END> [ ( <PROCEDURE> | <FUNCTION>) ] [ id2=designator() ] <SEMICOLON>
	| <SEMICOLON>
	)
    
    {
    	if (id2 != null && !id2.equals(id)) {
    	    id2.setParent(sub);
			erm.addError (new ZamiaException ("Closing id doesn't match (was expecting '"+id+"')", id2.getLocation()));
		} 
    	
    	return sub;
    }
    
}

AliasDeclaration alias_declaration() throws ZamiaException :
{
	Identifier id;
	TypeDefinition td = null;
	Name n;
	Signature s=null;	
	Token t;
}
{
	t=<ALIAS> id = designator()
	[ <COLON> td=subtype_indication() ] <IS> n=name() [ s=signature() ] <SEMICOLON>
	
	{
		return new AliasDeclaration(id.getImage(), td, n, s, getLocation(t));
	}
}

ArrayList<ConfigurationSpecification> configuration_specification() throws ZamiaException :
{
	ArrayList<ConfigurationSpecification> res = new ArrayList<ConfigurationSpecification>();
	ComponentSpecification cs;
	BindingIndication bi;
}
{
  <FOR> cs=component_specification() bi=binding_indication() <SEMICOLON>
  {
  	int n = cs.getNumIds();
  	for (int i = 0; i<n; i++) {
  		Identifier id = cs.getId(i);
  		
  		res.add(new ConfigurationSpecification(bi, cs.getName(), id.getImage(), null, id.getLineCol()));
  	}
  	
  	return res;
  }
}

DisconnectionSpecification disconnection_specification() throws ZamiaException :
{
	Token t;
	Operation expr;
	GuardedSignalSpecification gss;
}
{
	t=<DISCONNECT> gss = guarded_signal_specification() <AFTER> expr = expression() <SEMICOLON>
	{
		return new DisconnectionSpecification(gss, expr, null, getLocation(t));
	}
}

GuardedSignalSpecification guarded_signal_specification() throws ZamiaException :
{
	Name typeMark;
	SignalList sl;
}
{
	sl = signal_list() <COLON> typeMark = name()
	{
		return new GuardedSignalSpecification(sl, typeMark, null, sl.getLineCol());
	}
}

SignalList signal_list() throws ZamiaException:
{
	SignalList res;
	Name n;
	Token t;
}
{
	(
	n = name() { res = new SignalList(n, null, n.getLineCol()); }
		( <COMMA> n = name() { res.add(n); } )*
	| t=<OTHERS>
		{ res = new SignalList (SignalList.KIND_OTHERS, null, getLocation(t)); }
	| t=<ALL>
		{ res = new SignalList (SignalList.KIND_ALL, null, getLocation(t)); }
	)	
	{
		return res;
	}
}

GroupConstituent group_constituent() throws ZamiaException:
{
	Name name;
	Token t;
}
{
	( name = name() 
		{ return new GroupConstituent(name, null, name.getLineCol());}
	| t=<character_literal>  
		{ return new GroupConstituent(t.image, null, getLocation(t)); }
	)
}

ArrayList<GroupConstituent> group_constituent_list() throws ZamiaException:
{
	GroupConstituent gc;
	ArrayList<GroupConstituent> res;
}
{
	{ res = new ArrayList<GroupConstituent>(); }
	gc = group_constituent() {res.add(gc);}
	( <COMMA> gc=group_constituent()  {res.add(gc);})*
	{ return res;}
}


GroupTemplateDeclaration group_template_declaration() throws ZamiaException :
{
	Identifier id;
	Token t;
}
{
	t=<GROUP> id=identifier() <IS> <LPAREN> entity_class_entry_list() <RPAREN> <SEMICOLON>
	{ return new GroupTemplateDeclaration (id.getImage(), null, getLocation(t)); }
}

GroupDeclaration group_declaration() throws ZamiaException :
{
	Token t;
	Identifier id;
	Name n;
}
{
	t=<GROUP> id=identifier() <COLON> n=name()
	//<LPAREN> gcl = group_constituent_list() <RPAREN> already covered by name
	<SEMICOLON>
	{
		return new GroupDeclaration(id.getImage(),n,null,getLocation(t));
	}
}
 
TypeDefinitionProtected protected_type_body () throws ZamiaException:
{
	Token t;
}
{
	t=<PROTECTED> <BODY>
           protected_type_body_declarative_part()
	<END> <PROTECTED> <BODY> [ identifier() ]
	{
		return new TypeDefinitionProtected(null, getLocation(t));
	}
}
 
void protected_type_body_declarative_item () throws ZamiaException:
{
}
{
	(
       subprogram()
       | type_declaration()
       | subtype_declaration()
       | constant_declaration()
       | variable_declaration()
       | file_declaration()
       | alias_declaration()
  	   | LOOKAHEAD(attribute_declaration())
         attribute_declaration()
       | attribute_specification()
       | use_clause()
   	   | LOOKAHEAD(<GROUP> identifier() <IS>)
         group_template_declaration()
       | group_declaration()
	)
}

void protected_type_body_declarative_part() throws ZamiaException:
{
}
{
       ( protected_type_body_declarative_item() )*
}

TypeDefinitionProtected protected_type_declaration() throws ZamiaException:
{
	Token t;
}
{
	t = <PROTECTED>
             protected_type_declarative_part()
	<END> <PROTECTED> [ identifier() ]
	{
		return new TypeDefinitionProtected(null, getLocation(t));
	}
}

void protected_type_declarative_item() throws ZamiaException:
{
}
{
	(
        subprogram()
       | attribute_specification()
       | use_clause()
    )
}

void protected_type_declarative_part() throws ZamiaException:
{
}
{
	( protected_type_declarative_item() )*
}

TypeDefinitionProtected protected_type_definition() throws ZamiaException:
{
	TypeDefinitionProtected res;
}
{
	(
	LOOKAHEAD(<PROTECTED> <BODY>) res = protected_type_body()
	| res = protected_type_declaration()
	)
	{
		return res;
	}
}

/**
 *
 * 1076-2008 PSL
 *
 */
 
// A.4.3 PSL directives
 
void psl_psl_directive() throws ZamiaException:
{
	Identifier label;
	String labelS = null;
}
{
	[ label = identifier() <COLON> { labelS = label.getImage(); } ] 

    { SetState(PSL_MODE); } 
	
	// FIXME
	( psl_assert_directive()
//	| stmt = psl_assume_directive()
//	| stmt = psl_assume_guarantee_directive()
//	| stmt = psl_restrict_directive()
//	| stmt = psl_restrict_guarantee_directive()
//	| stmt = psl_cover_directive()
	| psl_cover_directive(labelS)
//	| stmt = psl_fairness_statement()
	)	
	
	<PSL_SEMICOLON>

	{ SetState(DEFAULT); }
	
}

void psl_assert_directive() throws ZamiaException:
{
}
{
      <PSL_ASSERT> psl_property() [ <PSL_REPORT> psl_psl_expression() ] 
}
 
void psl_cover_directive(String aLabel) throws ZamiaException:
{
}
{
      <PSL_COVER> psl_sere() [ <PSL_REPORT> psl_psl_expression() ] 
}
 
//  A.4.4 PSL properties

void psl_property() throws ZamiaException:
{
}
{
	[ psl_replicator() ] 
	// FIXME
//	(
        psl_fl_property()
//        | psl_obe_property()
//    )
}

void psl_replicator() throws ZamiaException:
{
}
{
  <PSL_FORALL> psl_identifier() [ <PSL_LPAREN> psl_range() <PSL_RPAREN> ] <PSL_IN> psl_value_set() <PSL_COLON>
}

void psl_value_set() throws ZamiaException:
{
}
{
   (<PSL_BOOLEAN>
   | <PSL_LBRACE> psl_range() ( <PSL_COMMA> psl_range() )* <PSL_RBRACE>
   )
}

void psl_range() throws ZamiaException:
{
}
{
   psl_simple_expression() [ LOOKAHEAD ( <PSL_TO> | <PSL_DOWNTO>) psl_direction() psl_simple_expression() ]	
}

void psl_fl_property() throws ZamiaException:
{
}
{
	psl_fl_property_primary()
	
	[ LOOKAHEAD(1)
		(  <PSL_AND> psl_fl_property_primary()
		  | <PSL_OR> psl_fl_property_primary()
		  | <PSL_IMPLIF> psl_fl_property_primary()
		  | <PSL_IMPLIFF> psl_fl_property_primary()
		  | <PSL_UNTIL>  psl_fl_property_primary()
		  | <PSL_UNTILEXCL>  psl_fl_property_primary()
		  | <PSL_UNTILEXCL_>  psl_fl_property_primary()
		  | <PSL_UNTIL_> psl_fl_property_primary()
		)
	]
}

void psl_fl_property_primary() throws ZamiaException:
{
}
{
	[ LOOKAHEAD(1) <PSL_NOT> ]
	
	(
           LOOKAHEAD (<PSL_LPAREN>) <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | LOOKAHEAD (<PSL_LBRACE>)  psl_sequence() [ LOOKAHEAD(1) (<PSL_EXCL> | <PSL_SUFFOVERLAP> psl_fl_property() | <PSL_SUFFNONOVERLAP> psl_fl_property() ) ]
          | LOOKAHEAD (psl_psl_expression()) psl_psl_expression()
//          | psl_property_name() [ <PSL_LPAREN> psl_actual_parameter_list() <PSL_RPAREN> ]
          | <PSL_ALWAYS> psl_fl_property()
          | <PSL_NEVER> psl_fl_property()
          | <PSL_EVENTUALLYEXCL> psl_fl_property()
          | <PSL_X> <PSL_LBRACKET> psl_psl_expression() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
		  | <PSL_XEXCL> <PSL_LBRACKET> psl_psl_expression() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT> [ <PSL_LBRACKET> psl_psl_expression() <PSL_RBRACKET> ] <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXTEXCL> [ <PSL_LBRACKET> psl_psl_expression() <PSL_RBRACKET> ] <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_A> <PSL_LBRACKET> psl_range() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_AEXCL> <PSL_LBRACKET> psl_range() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_E> <PSL_LBRACKET> psl_range() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_EEXCL> <PSL_LBRACKET> psl_range() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_EVENTEXCL> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN> [ <PSL_LBRACKET> psl_psl_expression() <PSL_RBRACKET> ] <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_EVENT> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN> <PSL_LBRACKET> psl_psl_expression() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_EVENT_AEXCL> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN> [ <PSL_LBRACKET> psl_range() <PSL_RBRACKET> ] <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_EVENT_A> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN> <PSL_LBRACKET> psl_range() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_EVENT_EEXCL> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN> <PSL_LBRACKET> psl_range() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
          | <PSL_NEXT_EVENT_E> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN> <PSL_LBRACKET> psl_range() <PSL_RBRACKET> <PSL_LPAREN> psl_fl_property() <PSL_RPAREN>
    )
    ( LOOKAHEAD (<PSL_AT> | <PSL_ABORT> | <PSL_ASYNC_ABORT> | <PSL_SYNC_ABORT> )
      ( <PSL_AT> psl_psl_expression() 
      | <PSL_ABORT> psl_psl_expression() 
      | <PSL_ASYNC_ABORT> psl_psl_expression() 
      | <PSL_SYNC_ABORT> psl_psl_expression() 
      )
    )*
}

 
//  A.4.5 Sequential Extended Regular Expressions (SEREs)
 
void psl_sere() throws ZamiaException:
{
}
{
	psl_sere_factor() 
	(
		<PSL_PIPE> psl_sere_factor()
		| <PSL_CONCAT> psl_sere_factor()
		| <PSL_LAND> psl_sere_factor()
		| <PSL_WITHIN> psl_sere_factor()
	)*
}

void psl_sere_factor() throws ZamiaException:
{
}
{
	(
		psl_sequence() | psl_psl_expression()
	)	
	
	[ 
	  ( <PSL_REPSTAR> [ psl_count() ] <PSL_RBRACKET>
	  | <PSL_REPPLUS> 
	  | <PSL_REPNON> psl_count() <PSL_RBRACKET>
	  | <PSL_EQ> psl_count() 
	  | <PSL_FOLLOWS> psl_count()
	  ) 
	] 
	
	[ <PSL_AT> psl_psl_expression() ]
	
}

void psl_sequence() throws ZamiaException:
{
}
{
	<PSL_LBRACE> psl_sere() ( ( <PSL_SEMICOLON> | <PSL_COLON> ) psl_sere() ) * <PSL_RBRACE>
}

void psl_count() throws ZamiaException: 
{
}
{
	psl_psl_expression() [ <PSL_TO> ( <PSL_INF> | psl_psl_expression()) ]
}

// A.4.8 Forms of expression

void psl_psl_expression() throws ZamiaException:
{
}
{
	( LOOKAHEAD(1) <PSL_PREV> <PSL_LPAREN> psl_psl_expression() [ <PSL_COMMA> psl_psl_expression() [ <PSL_COMMA> psl_psl_expression() ] ] <PSL_RPAREN>
    | <PSL_NEXT> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN>
    | <PSL_STABLE> <PSL_LPAREN> psl_psl_expression() [ <PSL_COMMA> psl_psl_expression() ] <PSL_RPAREN>
    | <PSL_ROSE> <PSL_LPAREN> psl_psl_expression() [ <PSL_COMMA> psl_psl_expression() ] <PSL_RPAREN>
    | <PSL_FELL> <PSL_LPAREN> psl_psl_expression() [ <PSL_COMMA> psl_psl_expression() ] <PSL_RPAREN>
    | <PSL_ENDED> <PSL_LPAREN> psl_sequence() [ <PSL_COMMA> psl_psl_expression() ] <PSL_RPAREN>
    | <PSL_ISUNKNOWN> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN>
	| <PSL_COUNTONES> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN>
    | <PSL_ONEHOT> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN>
    | <PSL_ONEHOT0> <PSL_LPAREN> psl_psl_expression() <PSL_RPAREN>
    | <PSL_NONDET>  <PSL_LPAREN> psl_value_set() <PSL_RPAREN>
    | <PSL_NONDET_VECTOR> <PSL_LPAREN> psl_psl_expression() <PSL_COMMA> psl_value_set() <PSL_RPAREN>
    | psl_expression() 
	)
		
	( LOOKAHEAD(1) ( <PSL_IMPLIF> psl_expression() | <PSL_IMPLIFF> psl_expression() | <PSL_UNION> psl_expression() ) )*
}

void psl_expression() throws ZamiaException :
{ 
}
{
	psl_relation()
	( LOOKAHEAD(1) 
		( <PSL_AND>
		| <PSL_OR>
		| <PSL_NAND>
		| <PSL_NOR>
		| <PSL_XOR>
		| <PSL_XNOR>
		)
		psl_relation() 
	)*
}

void psl_relation() throws ZamiaException :
{ 
}
{
	psl_shift_expression() 
	[ LOOKAHEAD(psl_relational_operator()) psl_relational_operator() psl_shift_expression() ]
}

void psl_relational_operator():
{}
{
    <PSL_EQ>
  | <PSL_NEQ>
  | <PSL_LO>
  | <PSL_LE>
  | <PSL_GT>
  | <PSL_GE>
}

void psl_shift_expression() throws ZamiaException :
{ 
}
{
	psl_simple_expression() 
	[  psl_shift_operator() psl_simple_expression() ]
}

void psl_shift_operator() throws ZamiaException :
{}
{
    <PSL_SLL>
  | <PSL_SRL>
  | <PSL_SLA>
  | <PSL_SRA>
  | <PSL_ROL>
  | <PSL_ROR>
}

void psl_simple_expression() throws ZamiaException :
{ 
}
{
	[ ( <PSL_ADD>  | <PSL_SUB> ) ] psl_term()

	(LOOKAHEAD (<PSL_ADD> | <PSL_SUB> | <PSL_CONCAT>)
		( 
		  <PSL_ADD> 
		| <PSL_SUB> 
		| <PSL_CONCAT> 
		)

		psl_term() 
    )*
}

void psl_term() throws ZamiaException :
{ 
}
{
	psl_factor() 
	(LOOKAHEAD(4)
		psl_multiplying_operator() 
		psl_factor()
	)*
}

void psl_multiplying_operator() throws ZamiaException :
{
}
{
	( 
	<PSL_MUL>
	| <PSL_DIV>
	| <PSL_MOD>
	| <PSL_REM>
	)
}

void psl_factor() throws ZamiaException :
{
}
{
	(
		<PSL_ABS> psl_primary()
		| <PSL_NOT> psl_primary()
		| psl_primary() 
			[ LOOKAHEAD(<PSL_EXP> psl_primary()) <PSL_EXP> psl_primary() 
			]
	)
}


void psl_primary() throws ZamiaException :
{
}
{
	( LOOKAHEAD(<PSL_NEW>) psl_allocator()
	| LOOKAHEAD(<psl_string_literal> <PSL_LPAREN>)
		psl_operation_call() 
	| LOOKAHEAD(psl_numeric_literal() | <psl_character_literal> | <psl_string_literal> | <psl_bit_string_literal> | <PSL_NULL>)
		psl_pure_literal()
	| LOOKAHEAD(psl_identifier())
		psl_pure_name()
	| LOOKAHEAD( <PSL_LPAREN> psl_expression() <PSL_RPAREN>)
		<PSL_LPAREN> psl_expression() <PSL_RPAREN>
	| psl_aggregate()
	)
}

void psl_allocator() throws ZamiaException:
{
}
{
	<PSL_NEW>
	psl_subtype_indication()
}

void psl_subtype_indication() throws ZamiaException :
{
}
{
	[ LOOKAHEAD (psl_name() psl_name()) psl_name() ] psl_name() [ LOOKAHEAD(2) psl_constraint() ]
}

void psl_constraint() throws ZamiaException :
{
}
{
	(
      psl_range_constraint() 
	| psl_index_constraint()
	)
}

void psl_index_constraint() throws ZamiaException :
{
}
{
	<PSL_LPAREN> psl_discrete_range() 
	( <PSL_COMMA> psl_discrete_range()   )* <PSL_RPAREN>
}

void psl_discrete_range() throws ZamiaException :
{
}
{
	( LOOKAHEAD(psl_simple_expression() psl_direction() )
		psl_range() 
	| LOOKAHEAD (psl_name() psl_name() psl_constraint()) 		
		psl_subtype_indication()
	| LOOKAHEAD (psl_name() psl_constraint()) 		
		psl_subtype_indication()
	| LOOKAHEAD (psl_name() psl_name()) 		
		psl_subtype_indication()
	| LOOKAHEAD (psl_name()) 		
		psl_subtype_indication()
	| psl_range() 
	)
}

void psl_range_constraint() throws ZamiaException :
{
}
{
	<PSL_RANGE> (LOOKAHEAD(psl_range()) psl_range() | psl_name() )
}

void psl_operation_call() throws ZamiaException:
{
}
{
	<psl_string_literal>

	[ LOOKAHEAD(<PSL_LBRACKET>) psl_signature() ]

	[ LOOKAHEAD( (<PSL_LPAREN> | <PSL_PERIOD> | <PSL_TICK> )) psl_name_extension() ]
}

void psl_pure_literal() throws ZamiaException :
{
}
{
	(
		LOOKAHEAD( psl_numeric_literal() )
		psl_numeric_literal()
 	| <psl_character_literal>
	| <psl_bit_string_literal> 
	| <psl_string_literal> 
	| <PSL_NULL>
	)
}


void psl_numeric_literal() throws ZamiaException :
{
}
{
	( LOOKAHEAD (psl_physical_literal())
  	  psl_physical_literal()
	| psl_abstract_literal() )
}

void psl_physical_literal() throws ZamiaException :
{
}
{
	psl_abstract_literal() 
	psl_name()
}

void psl_name() throws ZamiaException:
{
}
{

	( psl_identifier() 
	| <psl_string_literal>
	)

	[ LOOKAHEAD(<PSL_LBRACKET>) psl_signature() ]

	[ LOOKAHEAD( (<PSL_LPAREN> | <PSL_PERIOD> | <PSL_TICK> )) psl_name_extension() ]
}

void psl_pure_name() throws ZamiaException:
{
}
{

	psl_identifier()

	[ LOOKAHEAD( <PSL_LBRACKET> ( psl_identifier() | <PSL_RETURN> )  ) psl_signature() ]

	[ LOOKAHEAD( ( <PSL_LPAREN> | <PSL_PERIOD> | <PSL_TICK> )) psl_name_extension() ]
}

void psl_name_extension() throws ZamiaException:
{
}
{
	(
	  LOOKAHEAD(<PSL_TICK> <PSL_RANGE> )
		<PSL_TICK> <PSL_RANGE>
		[ LOOKAHEAD( <PSL_LPAREN> psl_expression() <PSL_RPAREN>) <PSL_LPAREN> psl_expression() <PSL_RPAREN> ]
	| LOOKAHEAD(<PSL_TICK> psl_identifier()) <PSL_TICK> psl_identifier()
		[ LOOKAHEAD( <PSL_LPAREN> psl_expression() <PSL_RPAREN>) <PSL_LPAREN> psl_expression() <PSL_RPAREN> ]
	| LOOKAHEAD(<PSL_TICK> <PSL_LPAREN> psl_expression() <PSL_LPAREN>)
		<PSL_TICK> <PSL_LPAREN> psl_expression() <PSL_RPAREN>
	| LOOKAHEAD(<PSL_TICK>)
		<PSL_TICK> psl_aggregate()
	| <PSL_PERIOD> psl_suffix()
	| LOOKAHEAD( <PSL_LPAREN> psl_range() (<PSL_COMMA> psl_range() )* <PSL_LPAREN> )
		<PSL_LPAREN> psl_range() 
		( <PSL_COMMA> psl_range() )* <PSL_RPAREN>
	| LOOKAHEAD( <PSL_LPAREN> psl_expression() (<PSL_COMMA> psl_expression() )* <PSL_LPAREN>) 
		<PSL_LPAREN> psl_expression() 
	        ( <PSL_COMMA> psl_expression() )* <PSL_RPAREN>
	| <PSL_LPAREN> psl_association_list() <PSL_RPAREN> 
	)
  [  LOOKAHEAD( (<PSL_TICK> | <PSL_PERIOD> | <PSL_LPAREN> ) ) psl_name_extension() ]
}

void psl_suffix() throws ZamiaException :
{
}
{
	(
		psl_identifier() 
	| <psl_character_literal>
	| <psl_string_literal>
	| <PSL_ALL>
	)
}

void psl_association_list()  throws ZamiaException :
{
}
{
	psl_association_element()
	( <PSL_COMMA> psl_association_element() )*
}

void psl_association_element()  throws ZamiaException :
{
}
{
	[ LOOKAHEAD( psl_formal_part() <PSL_FOLLOWS> ) psl_formal_part() <PSL_FOLLOWS>  ]
	psl_actual_part()
}

void psl_formal_part() throws ZamiaException :
{
}
{
	( LOOKAHEAD( psl_name() <PSL_LPAREN> psl_name() <PSL_RPAREN>)
		psl_name() <PSL_LPAREN> psl_name() <PSL_RPAREN> 
	| psl_name() 
	)
}

void psl_actual_part()  throws ZamiaException :
{
}
{
	psl_actual_designator()
}

void psl_actual_designator() throws ZamiaException :
{
}
{
	( <PSL_OPEN>
	| psl_expression()
	)
}

void psl_signature() throws ZamiaException :
{
}
{
	<PSL_LBRACKET>
	
	( LOOKAHEAD(psl_identifier())
		psl_name() 
		( LOOKAHEAD (<PSL_COMMA> psl_name() ) <PSL_COMMA> psl_name() )*
		[ LOOKAHEAD (<PSL_RETURN>) <PSL_RETURN> psl_name() ]
	| <PSL_RETURN> psl_name() 
	)
	<PSL_RBRACKET>
}

void psl_abstract_literal() throws ZamiaException :
{
}
{
	( <psl_decimal_literal>
	| <psl_based_literal>
	)
}

void psl_aggregate() throws ZamiaException :
{
}
{
	<PSL_LPAREN> psl_element_association()  
	( <PSL_COMMA> psl_element_association()  )* <PSL_RPAREN>
}

void psl_element_association() throws ZamiaException :
{
}
{
	[ LOOKAHEAD (psl_choices() <PSL_FOLLOWS> ) choices() <PSL_FOLLOWS> ]
	psl_expression()
}

void psl_choices() throws ZamiaException :
{
}
{
	psl_choice()
	( <PSL_PIPE> psl_choice() )*
}


void psl_choice() throws ZamiaException :
{
}
{
	( LOOKAHEAD(psl_simple_expression() psl_direction())
		psl_range()
	| <PSL_OTHERS>
	| psl_simple_expression()
	)
}

void psl_direction() throws ZamiaException :
{}
{
	( <PSL_TO>  | <PSL_DOWNTO> )
}


void psl_identifier() throws ZamiaException :
{ 
}
{  
	(  <psl_basic_identifier> 
	|  <psl_extended_identifier> 
	)
}


/**
 *
 * for error recovery:
 *
 */
JAVACODE void error_skipto(int kind, String message, ParseException e)
{
  erm.addError (new ZamiaException (message+"\n"+e, new SourceLocation(sf, getLocation(e.currentToken.next))));
  Token t;
  do
  {
    t = getNextToken();
  } while ((t.kind != kind) && t.kind != EOF);
}
